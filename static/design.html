<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI PDF & Video ‚Üí MCQ Generator</title>
  <!-- <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"> -->
  <!-- Updated Bootstrap 5.3.2 -->
  <!-- Add PDF.js library in <head> section -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      background: url("https://guptadeepak.com/content/images/size/w2000/2024/07/The-Future-of-AI-and-Its-Impact-on-Humanity.webp") no-repeat center center fixed;
      background-size: cover;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
    }
    body::before {
      content: "";
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(255,255,255,0.09);
      backdrop-filter: blur(8px);
      z-index: -1;
    }

    header {
      background: linear-gradient(to right, #0d47a1, #c62828);
      padding: 10px 20px;
      color: white;
      display: none;
    }

    /* Login Page */
    #loginPage {
      height: 100vh; display: flex; justify-content: center; align-items: center;
    }
    .login-card {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 16px;
      padding: 40px;
      width: 380px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
      backdrop-filter: blur(10px);
      animation: fadeInUp 1s ease forwards;
    }
    .login-card h3 {
      text-align: center;
      margin-bottom: 25px;
      color: #0d47a1;
      font-weight: 700;
    }
    .form-control { border-radius: 8px; border: 1px solid #1976d2; }
    .btn-login {
      background: linear-gradient(135deg, #1976d2, #42a5f5);
      color: #fff; border: none;
      width: 100%; padding: 12px; border-radius: 10px;
      font-size: 1.1rem; margin-top: 15px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    .btn-login:hover {
      transform: translateY(-5px) scale(1.03);
      box-shadow: 0 0 15px rgba(255,255,255,0.6),
                  0 0 30px rgba(255,255,255,0.4),
                  0 8px 25px rgba(0,0,0,0.4);
      filter: brightness(1.1);
    }
    #loginError { display:none; text-align:center; margin-top:10px; }

    /* Stats card */
    .stats-card {
      border-radius: 12px; padding: 20px; text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      opacity: 0; transform: translateY(40px);
      animation: fadeInUp 1s ease forwards; transition: all 0.3s ease;
      background: linear-gradient(135deg, #1976d2, #42a5f5); color: #fff;
    }
    .stats-card:hover {
      transform: translateY(-10px) scale(1.05);
      box-shadow: 0 0 15px rgba(255,255,255,0.6), 0 0 30px rgba(255,255,255,0.4), 0 8px 25px rgba(0,0,0,0.4);
      filter: brightness(1.2);
    }

    .section-card {
      background: linear-gradient(135deg, #e3f2fd, #bbdefb);
      border-radius: 12px; padding: 25px; margin-bottom: 40px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      opacity: 0; transform: scale(0.9) translateY(40px);
      animation: fadePop 1s ease forwards; transition: all 0.3s ease;
    }

    .upload-box {
      border: 2px dashed #0d47a1; padding: 25px; border-radius: 12px;
      background: rgba(255,255,255,0.9); text-align: center;
    }
    /* Add this to your existing styles */
    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    .page {
      flex: 1;
    }

    #mainFooter {
      margin-top: auto;
    }
    footer {
      background: linear-gradient(to right, #c62828, #0d47a1);
      color: #fff; padding: 12px; text-align: center; font-size:0.9rem;
      display: none;
    }

    @keyframes fadeInUp { from {opacity:0; transform:translateY(40px);} to {opacity:1; transform:translateY(0);} }
    @keyframes fadePop { from {opacity:0; transform:scale(0.9) translateY(40px);} to {opacity:1; transform:scale(1) translateY(0);} }

    /* Main nav */
    .main-nav { height:80vh; display:flex; justify-content:center; align-items:center; display:none; }
    .nav-vertical { display:flex; flex-direction:column; gap:20px; align-items:center; }
    .nav-vertical .btn {
      padding: 15px 30px; font-size: 1.1rem; border-radius: 12px;
      color: #fff; background: linear-gradient(135deg, #1976d2, #42a5f5);
      border: none; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      opacity: 0; transform: translateY(40px);
      animation: fadeInUp 1s ease forwards; transition: all 0.3s ease;
      width: 400px; text-align: left; padding-left: 20px;
    }
    .nav-vertical .btn:hover {
      transform: translateY(-10px) scale(1.04);
      box-shadow: 0 0 15px rgba(255,255,255,0.6), 0 0 30px rgba(255,255,255,0.4), 0 8px 25px rgba(0,0,0,0.4);
      filter: brightness(1.12);
    }
    .page { display: none; padding-top: 18px; }
    
    /* Questions table styles */
    .question-table {
      max-height: 600px;
      overflow-y: auto;
    }
    .question-row {
      border-left: 4px solid #1976d2;
    }
    .question-row.mcq {
      border-left-color: #28a745;
    }
    .question-row.descriptive {
      border-left-color: #ffc107;
    }

   .ai-card {
          background: rgba(255, 255, 255, 0.05);
          border-radius: 20px;
          padding: 40px;
          backdrop-filter: blur(10px);
          box-shadow: 0 0 30px rgba(0, 255, 255, 0.6),
              0 0 60px rgba(0, 119, 255, 0.4);
          text-align: center;
          transition: all 0.3s ease;
      }

      .ai-card:hover {
          box-shadow: 0 0 50px rgba(0, 255, 255, 0.9),
              0 0 100px rgba(0, 119, 255, 0.6);
          transform: scale(1.05);
      }

      .brand-title {
          font-weight: bold;
          font-size: 50px;
          color: #fff;
          text-shadow: 0 0 20px cyan, 0 0 40px #007bff, 0 0 60px #00e5ff;
          letter-spacing: 2px;
      }
    /* Sticky table header */
.table thead th {
  position: sticky;
  top: 0;
  background: #f8f9fa;  /* Bootstrap table-light background */
  z-index: 2;
}
/* Remove gradient background from main-nav */
.main-nav {
    background: none !important;
    min-height: 100vh;
    display: flex;
    align-items: center;
    padding: 40px 0;
}

/* Add a subtle background pattern instead */
body {
    background-color: #f8f9fa;
    background-image: 
        radial-gradient(circle at 15% 50%, rgba(29, 78, 216, 0.05) 0%, transparent 55%),
        radial-gradient(circle at 85% 30%, rgba(220, 38, 38, 0.05) 0%, transparent 55%);
}

/* Update the AI card to be transparent */
.ai-card {
    background: transparent !important;
    box-shadow: none !important;
    backdrop-filter: none !important;
    padding: 20px !important;
}

.brand-title {
    font-weight: 800;
    font-size: clamp(2.5rem, 6vw, 4rem);
    color: #1e40af;
    text-shadow: 0 4px 12px rgba(30, 64, 175, 0.3);
    letter-spacing: 1px;
    line-height: 1.1;
    margin-bottom: 10px;
}

/* Card styles */
.nav-card {
    height: 100%;
    border: none;
    border-radius: 16px;
    overflow: hidden;
    transition: all 0.3s ease;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    background: white;
}

.nav-card:hover {
    transform: translateY(-10px) scale(1.02);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
}

/* Card header gradient effects */
.nav-card .card-header {
    border: none;
    font-weight: 600;
    letter-spacing: 0.5px;
    padding: 20px;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

/* Button styles */
.nav-card .btn {
    border: none;
    border-radius: 10px;
    padding: 15px;
    font-weight: 500;
    transition: all 0.3s ease;
    text-align: center;
    position: relative;
    overflow: hidden;
}

.nav-card .btn::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s ease;
}

.nav-card .btn:hover::after {
    left: 100%;
}

.nav-card .btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
}

/* Ensure cards have equal height */
.h-100 {
    height: 100%;
}

/* Responsive adjustments */
@media (max-width: 992px) {
    .main-nav {
        padding: 30px 0;
    }
    
    .brand-title {
        font-size: 3rem;
    }
    
    .col-md-4 {
        margin-bottom: 30px;
    }
}

@media (max-width: 768px) {
    .brand-title {
        font-size: 2.5rem;
    }
    
    .nav-card .btn {
        padding: 12px;
        font-size: 0.95rem;
    }
    
    .nav-card .card-header {
        padding: 15px;
        font-size: 1.2rem;
    }
}

@media (max-width: 576px) {
    .brand-title {
        font-size: 2rem;
    }
    
    .main-nav {
        padding: 20px 0;
    }
}

/* Card animations */
@keyframes fadeInCards {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.nav-card {
    animation: fadeInCards 0.8s ease forwards;
}

.nav-card:nth-child(1) { animation-delay: 0.1s; }
.nav-card:nth-child(2) { animation-delay: 0.2s; }
.nav-card:nth-child(3) { animation-delay: 0.3s; }

/* Add a subtle border to cards for definition */
.nav-card {
    border: 1px solid rgba(0, 0, 0, 0.08);
}

  </style>
</head>

<body>



 <!-- NAV -->
 <!-- Main Navigation Page -->
<div id="mainPage" class="main-nav">
  <div class="container">
    <!-- First Row: Heading -->
    <div class="row mb-5">
      <div class="col-12 text-center">
        <div class="ai-card" style="background: transparent; box-shadow: none; padding: 30px;">
          <div class="brand-title" style="text-shadow: 0 0 20px cyan, 0 0 40px #007bff, 0 0 60px #00e5ff; color: #1e40af;">
            ICFAI AI Solutions
          </div>
          
        </div>
      </div>
    </div>

    <!-- Second Row: Three Cards in equal columns -->
    <div class="row g-4 justify-content-center">
      
      <!-- Card 1: Generate Questions -->
      <div class="col-md-4">
        <div class="nav-card section-card h-100">
          <h5 class="card-header text-center" style="background: linear-gradient(135deg, #1976d2, #42a5f5); color: white; border-radius: 12px 12px 0 0; padding: 20px; font-size: 1.3rem;">
            üìù Generate Questions
          </h5>
          <div class="card-body d-flex flex-column gap-3" style="padding: 25px;">
            <button class="btn btn-primary nav-btn" onclick="showPage('pdfPage')" style="padding: 15px; font-weight: 500;">
              Generate Questions from PDFs
            </button>
            <button class="btn btn-primary nav-btn" onclick="showPage('videoPage')" style="padding: 15px; font-weight: 500;">
              Generate Questions from Video
            </button>
            <button class="btn btn-primary nav-btn" onclick="showPage('courseSelectionPage')" style="padding: 15px; font-weight: 500;">
              Generate Questions from Course
            </button>
          </div>
        </div>
      </div>

      <!-- Card 2: View Questions -->
      <div class="col-md-4">
        <div class="nav-card section-card h-100">
          <h5 class="card-header text-center" style="background: linear-gradient(135deg, #28a745, #20c997); color: white; border-radius: 12px 12px 0 0; padding: 20px; font-size: 1.3rem;">
            üëÅÔ∏è View Questions
          </h5>
          <div class="card-body d-flex flex-column gap-3" style="padding: 25px;">
            <button class="btn btn-success nav-btn" onclick="showPage('questionsPage')" style="background: linear-gradient(135deg, #28a745, #20c997); padding: 15px; font-weight: 500;">
              View Generated Questions
            </button>
            <button class="btn btn-success nav-btn" onclick="showPage('courseQuestionsPage')" style="background: linear-gradient(135deg, #28a745, #20c997); padding: 15px; font-weight: 500;">
              View Course Questions
            </button>
            <button class="btn btn-success nav-btn" onclick="showPage('generatePaperPage')" style="background: linear-gradient(135deg, #28a745, #20c997); padding: 15px; font-weight: 500;">
              Generate Question Paper
            </button>
          </div>
        </div>
      </div>

      <!-- Card 3: Other Tools -->
      <div class="col-md-4">
        <div class="nav-card section-card h-100">
          <h5 class="card-header text-center" style="background: linear-gradient(135deg, #ff6b35, #ff8e53); color: white; border-radius: 12px 12px 0 0; padding: 20px; font-size: 1.3rem;">
            üõ†Ô∏è Other Tools
          </h5>
          <div class="card-body d-flex flex-column gap-3" style="padding: 25px;">
            <a class="btn btn-warning text-white" href="http://192.168.1.80:8501" target="_blank" style="background: linear-gradient(135deg, #ff6b35, #ff8e53); padding: 15px; font-weight: 500;">
              Multilingual Video
            </a>
            <a class="btn btn-warning text-white" href="http://192.168.1.56/Summarizer/" target="_blank" style="background: linear-gradient(135deg, #ff6b35, #ff8e53); padding: 15px; font-weight: 500;">
              Text Summarizer
            </a>
          </div>
        </div>
      </div>

    </div>

   
  </div>
</div>


  <!-- PDF PAGE -->
  <div id="pdfPage" class="page container my-5">
    <h3 class="step-title"> Generate Questions from PDFs </h3>
    <div class="row g-3 mb-4">
      <button class="btn btn-light btn-sm float-end" style="margin-left:10px" onclick="goHome()">üè† Home</button>

      <div class="col-md-3"><div class="stats-card"><h6>PDFs uploaded</h6><h3>0</h3></div></div>
      <div class="col-md-3"><div class="stats-card"><h6>Pages (current PDF)</h6><h3>0</h3></div></div>
      <div class="col-md-3"><div class="stats-card"><h6>MCQs generated</h6><h3>0</h3></div></div>
      <div class="col-md-3"><div class="stats-card"><h6>Descriptive Qs</h6><h3>0</h3></div></div>
    </div>
    <div class="section-card">
      <div class="upload-box">
        
        <input id="pdfUploader" type="file" class="form-control form-control-sm btn-upload" accept=".pdf">
      </div>
    </div>
  </div>

  <!-- VIDEO PAGE -->
  <div id="videoPage" class="page container my-5">
    <h3 class="step-title"> Generate Questions from Video </h3>
    <button class="btn btn-light btn-sm float-end" style="margin-left:10px" onclick="goHome()">üè† Home</button>
    <div class="row g-3 mb-4">
      <div class="col-md-3"><div class="stats-card"><h6>Videos uploaded</h6><h3 id="videoUploadsStat">0</h3></div></div>
      <div class="col-md-3"><div class="stats-card"><h6>MCQs generated</h6><h3 id="videoMcqStat">0</h3></div></div>
    </div>

    <div class="section-card">
      <div class="upload-box">
        <input id="videoUploader" type="file" class="form-control form-control-sm btn-upload" accept="video/*">
      </div>
    </div>
  </div>


  <!-- QUESTIONS PAGE -->
<div id="questionsPage" class="page container my-5">
  <button class="btn btn-light btn-sm float-end" style="margin-left:10px" onclick="goHome()">üè† Home</button>
  <h3 class="step-title"> Generated Questions in Database </h3>
  
  
  <!-- ADD THESE DROPDOWNS HERE -->
  <div class="row mb-3">
    
    <div class="col-md-2 d-flex align-items-end">
   
</div>


</div>
  
  <!-- EXISTING SECTION CARD (NO CHANGES HERE) -->
  <div class="section-card">
    <div class="row mb-3">
        <div class="col-md-6">
            <input type="text" id="searchInput" class="form-control" placeholder="Search by topic or keyword...">
        </div>
        <div class="col-md-4">
            <select id="questionTypeSelect" class="form-select">
                <option value="all">All Types</option>
                <option value="MCQ">MCQ Only</option>
                <option value="Descriptive">Descriptive Only</option>
            </select>
        </div>
          <!-- ADD DIFFICULTY FILTER HERE -->
        <div class="col-md-2">
            <select id="difficultyFilter" class="form-select">
                <option value="all">All Difficulties</option>
                <option value="1">Level 1</option>
                <option value="2">Level 2</option>
                <option value="3">Level 3</option>
                <option value="4">Level 4</option>
                <option value="5">Level 5</option>
            </select>
        </div>
        <div class="col-md-2">
            <label class="form-label">PDF</label>
            <select id="pdfFilter" class="form-select">
                <option value="">All PDFs</option>
            </select>
        </div>
        <div class="col-md-2">
            <button type="button" id="searchBtn" class="btn btn-primary w-100">Search</button>
        </div>
    </div>
    <div id="questionsCount" class="mb-3"></div>
    <div id="questionsTable" class="question-table"></div>
  </div>
</div>
  
<!-- Generate Question Paper Page -->
<!-- Generate Question Paper Page -->
<div id="generatePaperPage" class="page container my-5">
  <button class="btn btn-light btn-sm float-end" style="margin-left:10px" onclick="goHome()">üè† Home</button>
  <h3 class="step-title">Generate Question Paper</h3>
  
  <div class="section-card">
    <!-- Step 1: PDF Selection -->
    <div class="card mb-4">
      <div class="card-header bg-primary text-white">
        <h6 class="mb-0"><i class="bi bi-file-pdf"></i> Step 1: Select PDF(s)</h6>
      </div>
      <div class="card-body">
        <div class="row">
          <div class="col-md-12">
            <label class="form-label">Select PDF(s)</label>
            <select id="paperPdfFilter" class="form-select" multiple size="5">
              <option value="">Loading PDFs...</option>
            </select>
            <small class="text-muted">Hold Ctrl/Cmd to select multiple PDFs</small>
          </div>
        </div>
      </div>
    </div>

    <!-- Step 2: Topic Selection (Hidden initially) -->
    <div class="card mb-4" id="paperTopicSelectionCard" style="display: none;">
      <div class="card-header bg-success text-white">
        <h6 class="mb-0"><i class="bi bi-tags"></i> Step 2: Select Topics</h6>
      </div>
      <div class="card-body">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <span class="small text-muted" id="paperTopicCount">0 topics available</span>
          <div>
            <button type="button" id="paperSelectAllTopics" class="btn btn-sm btn-outline-primary me-1">
              <i class="bi bi-check-square"></i> Select All
            </button>
            <button type="button" id="paperDeselectAllTopics" class="btn btn-sm btn-outline-secondary">
              <i class="bi bi-square"></i> Deselect All
            </button>
          </div>
        </div>
        <select id="paperTopicsSelect" class="form-select topic-select" multiple size="8">
          <!-- Topics will be loaded dynamically -->
        </select>
      </div>
    </div>

    <!-- Step 3: Question Type & Count -->
    <div class="card mb-4" id="paperQuestionTypeCard" style="display: none;">
      <div class="card-header bg-info text-white">
        <h6 class="mb-0"><i class="bi bi-question-circle"></i> Step 3: Question Type & Difficulty</h6>
      </div>
      <div class="card-body">
        <div class="row mb-3">
          <div class="col-md-12">
            <label class="form-label">Question Types</label>
            <div>
              <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="paperTypeMCQ" value="mcq" checked>
                <label class="form-check-label" for="paperTypeMCQ">MCQ</label>
              </div>
              <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="paperTypeDescriptive" value="descriptive" checked>
                <label class="form-check-label" for="paperTypeDescriptive">Descriptive</label>
              </div>
            </div>
          </div>
        </div>

        <div id="paperAvailableCountsInfo" class="alert alert-info">
          <i class="bi bi-info-circle"></i> Select topics to see available question counts by difficulty
        </div>

        <div id="paperDifficultySelection" style="display: none;">
          <h6>Select Number of Questions by Difficulty Level</h6>
          <div class="row g-3" id="paperDifficultyInputs">
            <!-- Will be populated dynamically -->
          </div>
        </div>
      </div>
    </div>

    <!-- Generate Button -->
    <div class="row" id="paperGenerateButtonContainer" style="display: none;">
      <div class="col-12">
        <button class="btn btn-primary btn-lg w-100" onclick="generateQuestionPaperNew()">
          üéØ Generate Question Paper
        </button>
        <div id="paperGenerationStatus" class="mt-3"></div>
      </div>
    </div>

    <!-- Results -->
    <div class="row mt-4">
      <div class="col-12">
        <div id="generatedPaperResults" class="mt-2 p-2" style="background:#ffffff; border-radius:8px; border:1px solid #e9ecef; max-height:60vh; overflow:auto;">
          <div class="text-center text-muted">
            Select PDFs and configure options above to generate a question paper
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- COURSE SELECTION PAGE - EXACT COPY OF BOTH PAGES -->
<!-- COURSE SELECTION PAGE - EXACT COPY OF BOTH PAGES -->
<div id="courseSelectionPage" class="page container my-5">
    <!-- ========== PART 2: EXACT COPY OF VIEW GENERATED QUESTIONS PAGE ========== -->
    <button class="btn btn-light btn-sm float-end" style="margin-left:10px" onclick="goHome()">üè† Home</button>
    
    <h3 class="step-title"> Course Selection & PDF Processing </h3>
    
    <!-- DROPDOWNS SECTION -->
    <div class="row mb-3">
        <div class="col-md-2">
            <label class="form-label">Program</label>
            <select id="courseSelectionProgramFilter" class="form-select">
                <option value="">Select Program</option>
            </select>
        </div>
        <div class="col-md-2">
            <label class="form-label">Branch</label>
            <select id="courseSelectionBranchFilter" class="form-select" disabled>
                <option value="">Select Branch</option>
            </select>
        </div>
        <div class="col-md-2">
            <label class="form-label">Academic Year</label>
            <select id="courseSelectionAcademicYearFilter" class="form-select" disabled>
                <option value="">Select Year</option>
            </select>
        </div>
        <div class="col-md-2">
            <label class="form-label">Semester</label>
            <select id="courseSelectionSemesterFilter" class="form-select" disabled>
                <option value="">Select Semester</option>
            </select>
        </div>
        <div class="col-md-2">
            <label class="form-label">Course</label>
            <select id="courseSelectionCourseFilter" class="form-select" disabled>
                <option value="">Select Course</option>
            </select>
        </div>
        <div class="col-md-2">
            <label class="form-label">Component</label>
            <select id="courseSelectionComponentFilter" class="form-select" disabled>
                <option value="">Select Component</option>
            </select>
        </div>
        
    </div>
    
    <!-- ========== PART 1: EXACT COPY OF PDF PAGE ========== -->
    <div class="row g-3 mb-4">
        <div class="col-md-3"><div class="stats-card"><h6>PDFs uploaded</h6><h3 id="courseSelectionPdfUploadsStat">0</h3></div></div>
        <div class="col-md-3"><div class="stats-card"><h6>Pages (current PDF)</h6><h3 id="courseSelectionPagesStat">0</h3></div></div>
        <div class="col-md-3"><div class="stats-card"><h6>MCQs generated</h6><h3 id="courseSelectionMcqStat">0</h3></div></div>
        <div class="col-md-3"><div class="stats-card"><h6>Descriptive Qs</h6><h3 id="courseSelectionDescStat">0</h3></div></div>
    </div>
    
    <div class="section-card">
        <div class="upload-box">
            <input id="courseSelectionPdfUploader" type="file" class="form-control form-control-sm btn-upload" accept=".pdf">
        </div>
    </div>
    <!-- ========== END OF PDF PAGE COPY ========== -->
    
    <hr class="my-5">
    
    
</div>

<!-- COURSE QUESTIONS PAGE -->
<div id="courseQuestionsPage" class="page container my-5">
    <button class="btn btn-light btn-sm float-end" style="margin-left:10px" onclick="goHome()">üè† Home</button>
    <h3 class="step-title"> Course Generated Questions </h3>
    
    <!-- DROPDOWNS SECTION -->
    <div class="row mb-3">
        <div class="col-md-2">
            <label class="form-label">Program</label>
            <select id="courseQProgramFilter" class="form-select">
                <option value="">Select Program</option>
            </select>
        </div>
        <div class="col-md-2">
            <label class="form-label">Branch</label>
            <select id="courseQBranchFilter" class="form-select" disabled>
                <option value="">Select Branch</option>
            </select>
        </div>
        <div class="col-md-2">
            <label class="form-label">Academic Year</label>
            <select id="courseQAcademicYearFilter" class="form-select" disabled>
                <option value="">Select Year</option>
            </select>
        </div>
        <div class="col-md-2">
            <label class="form-label">Semester</label>
            <select id="courseQSemesterFilter" class="form-select" disabled>
                <option value="">Select Semester</option>
            </select>
        </div>
        <div class="col-md-2">
            <label class="form-label">Course</label>
            <select id="courseQCourseFilter" class="form-select" disabled>
                <option value="">Select Course</option>
            </select>
        </div>
        <div class="col-md-2">
            <label class="form-label">PDF</label>
            <select id="courseQPdfFilter" class="form-select">
                <option value="">All PDFs</option>
            </select>
        </div>
        <div class="col-md-2 d-flex align-items-end">
            <button class="btn btn-primary w-100" onclick="applyCourseQFilters()">
                View All Questions
            </button>
        </div>
    </div>
    
    <!-- SEARCH AND FILTER SECTION -->
    <div class="section-card">
        <div class="row mb-3">
            <div class="col-md-6">
                <input type="text" id="courseQSearchInput" class="form-control" placeholder="Search by topic or keyword...">
            </div>
            <div class="col-md-2">
                <select id="courseQQuestionTypeSelect" class="form-select">
                    <option value="all">All Types</option>
                    <option value="MCQ">MCQ Only</option>
                    <option value="Descriptive">Descriptive Only</option>
                </select>
            </div>
            <div class="col-md-2">
                <select id="courseQDifficultyFilter" class="form-select">
                    <option value="all">All Difficulties</option>
                    <option value="1">Level 1</option>
                    <option value="2">Level 2</option>
                    <option value="3">Level 3</option>
                    <option value="4">Level 4</option>
                    <option value="5">Level 5</option>
                </select>
            </div>
            <div class="col-md-2">
                <button type="button" id="courseQSearchBtn" class="btn btn-primary w-100">Search</button>
            </div>
        </div>
        
        <div id="courseQuestionsCount" class="mb-3"></div>
        <div id="courseQuestionsTable" class="question-table"></div>
    </div>
</div>
<!-- Generation Progress Modal -->
<div class="modal fade" id="generationProgressModal" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">
          <i class="bi bi-hourglass-split"></i> Generating Questions
        </h5>
      </div>
      <div class="modal-body">
        <div class="text-center mb-3">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
        </div>
        <div id="generationProgressText" class="text-center mb-2">
          Processing your request...
        </div>
        <div id="generationProgressDetails" class="text-center small text-muted mb-3">
          Elapsed time: <span id="elapsedTime">0s</span>
        </div>
        <div class="progress" style="height: 5px;">
          <div class="progress-bar progress-bar-striped progress-bar-animated" 
               style="width: 100%"></div>
        </div>
        
        <!-- Timeout Warning (Hidden initially) -->
        <div id="timeoutWarning" class="alert alert-warning mt-3" style="display: none;">
          <i class="bi bi-exclamation-triangle"></i> 
          <strong>Taking longer than expected</strong>
          <p class="mb-0 small">The generation is taking longer than estimated. Would you like to continue waiting or cancel?</p>
        </div>
      </div>
      <!-- MODIFIED FOOTER - Cancel button always visible -->
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" id="cancelGenerationBtn" data-bs-dismiss="modal">
          <i class="bi bi-x-circle"></i> Cancel
        </button>
      </div>
    </div>
  </div>
</div>

  <!-- ADD THE QUESTION PAPER SECTION HERE -->
  <!-- Generate Question Paper (REPLACEMENT) -->
    <style>
    /* Filter section styles */
    .filter-section {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .level-input {
      width: 70px;
      text-align: center;
    }
    .topic-select {
      min-height: 120px;
    }
    /* local styles for editable questions table inside resultsDiv */
    #paperControls { margin-top: 10px; }
    #paperResultsTable { width: 100%; table-layout: fixed; word-break: break-word; }
    #paperResultsTable th, #paperResultsTable td { vertical-align: top; white-space: normal; }
    .editable { min-height: 28px; padding: 6px; border-radius: 4px; }
    .small-action { font-size: 0.9rem; }
    .select-col { width: 40px; text-align: center; }
    .id-col { width: 60px; }
    .type-col { width: 80px; }
    .actions-col { width: 110px; }
  </style>

  
 <script>
    // Helper state for paper UI (client-only)
    const PAPER_STATE = {
      loadedQuestions: [], // {id, topic, type, question, option_a..d, difficulty, flagged}
      selectedIds: new Set(),
      availableTopics: []
    };

    

    // Function to load filter options
    async function loadFilterOptions() {
        try {
            const response = await fetch(`${backendBase}/get_combined_filters`);
            const data = await response.json();

            

            // Populate PDF dropdown (fixed: select element + correct `if`)
            const pdfFilter = document.getElementById('pdfFilter');
            if (data.pdf_names && pdfFilter) {
                // keep the "All PDFs" option, clear others
                pdfFilter.innerHTML = '<option value="">All PDFs</option>';
                data.pdf_names.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    pdfFilter.appendChild(option);
                });
            }

            console.log('Filter options loaded:', data);

        } catch (error) {
            console.error('Error loading filter options:', error);
        }
    }


    

    // Render editable table into resultsDiv
    function renderEditableQuestionsTable() {
      const resultsDiv = document.getElementById('resultsDiv');
      if (!PAPER_STATE.loadedQuestions.length) {
        resultsDiv.innerHTML = '<div class="alert alert-info small mb-0">No flagged questions found. Questions removed from previous sessions will not appear here.</div>';
        return;
      }

      const table = document.createElement('table');
      table.id = 'paperResultsTable';
      table.className = 'table table-sm table-bordered';

      const thead = document.createElement('thead');
      thead.innerHTML = `
        <tr>
          <th class="select-col"><input id="paperSelectAllToggle" type="checkbox" title="Select all"></th>
          <th class="id-col">ID</th>
          <th class="type-col">Type</th>
          <th>Flagged Status</th>
          <th>Topic</th>
          <th>Question (click to edit)</th>
          <th>Options (click to edit; MCQ only)</th>
          <th style="width:110px">Difficulty</th>
          <th class="actions-col">Actions</th>
        </tr>
      `;
      table.appendChild(thead);

      const tbody = document.createElement('tbody');

      PAPER_STATE.loadedQuestions.forEach(q => {
        const tr = document.createElement('tr');
        tr.dataset.qid = q.id;

        // Checkbox
        const chkTd = document.createElement('td');
        chkTd.className = 'select-col text-center align-middle';
        const chk = document.createElement('input');
        chk.type = 'checkbox';
        chk.className = 'paper-select-row';
        chk.checked = PAPER_STATE.selectedIds.has(q.id);
        chk.addEventListener('change', (ev) => {
          if (ev.target.checked) PAPER_STATE.selectedIds.add(q.id);
          else PAPER_STATE.selectedIds.delete(q.id);
          updatePaperSummary();
        });
        chkTd.appendChild(chk);
        tr.appendChild(chkTd);

        // ID
        const idTd = document.createElement('td');
        idTd.textContent = q.id;
        tr.appendChild(idTd);

        // Type
        const typeTd = document.createElement('td');
        typeTd.innerHTML = `<span class="badge ${q.type === 'MCQ' ? 'bg-success' : 'bg-warning'}">${q.type}</span>`;
        tr.appendChild(typeTd);
        
        // Flagged Status
        const flagTd = document.createElement('td');
        const flagStatus = q.flagged === true ? 
          '<span class="badge bg-success">Approved</span>' : 
          q.flagged === false ? 
          '<span class="badge bg-danger">Not Approved</span>' : 
          '<span class="badge bg-secondary">Pending</span>';
        flagTd.innerHTML = flagStatus;
        tr.appendChild(flagTd);
        
        // Topic
        const topicTd = document.createElement('td');
        const topicDiv = document.createElement('div');
        topicDiv.className = 'editable';
        topicDiv.contentEditable = 'true';
        topicDiv.innerText = q.topic || '';
        topicDiv.addEventListener('input', (ev) => {
          q.topic = topicDiv.innerText.trim();
        });
        topicTd.appendChild(topicDiv);
        tr.appendChild(topicTd);

        // Question (editable)
        const qTd = document.createElement('td');
        const qDiv = document.createElement('div');
        qDiv.className = 'editable';
        qDiv.contentEditable = 'true';
        qDiv.innerText = q.question;
        qDiv.addEventListener('input', (ev) => {
          q.question = qDiv.innerText.trim();
        });
        qTd.appendChild(qDiv);
        tr.appendChild(qTd);

        // Options
        const optsTd = document.createElement('td');
        if (q.type === 'MCQ') {
          const optsWrapper = document.createElement('div');
          optsWrapper.style.display = 'grid';
          optsWrapper.style.gridTemplateColumns = '1fr 1fr';
          optsWrapper.style.gap = '6px';

          ['option_a','option_b','option_c','option_d'].forEach((optKey, i) => {
            const lbl = ['A','B','C','D'][i];
            const optBox = document.createElement('div');
            const optLabel = document.createElement('div');
            optLabel.style.fontWeight = '600';
            optLabel.style.fontSize = '0.85rem';
            optLabel.textContent = lbl + ')';
            const optDiv = document.createElement('div');
            optDiv.className = 'editable';
            optDiv.contentEditable = 'true';
            optDiv.innerText = q[optKey] || '';
            optDiv.addEventListener('input', () => {
              q[optKey] = optDiv.innerText.trim();
            });
            optBox.appendChild(optLabel);
            optBox.appendChild(optDiv);
            optsWrapper.appendChild(optBox);
          });
          optsTd.appendChild(optsWrapper);
        } else {
          optsTd.innerHTML = `<div class="text-muted small">N/A for descriptive</div>`;
        }
        tr.appendChild(optsTd);

        // Difficulty (editable select)
        const diffTd = document.createElement('td');
        const sel = document.createElement('select');
        sel.className = 'form-select form-select-sm';
        const blankOpt = document.createElement('option'); blankOpt.value = ''; blankOpt.textContent = '‚Äî';
        sel.appendChild(blankOpt);
        for (let i = 1; i <= 5; i++) {
          const o = document.createElement('option'); o.value = String(i); o.textContent = String(i);
          if (String(q.difficulty) === String(i)) o.selected = true;
          sel.appendChild(o);
        }
        sel.addEventListener('change', () => { q.difficulty = sel.value; });
        diffTd.appendChild(sel);
        tr.appendChild(diffTd);

        // Actions
        const actTd = document.createElement('td');
        actTd.className = 'text-center';

        // Approve button
        const approveBtn = document.createElement('button');
        approveBtn.className = 'btn btn-sm btn-success me-1';
        approveBtn.innerHTML = '‚úì Approve';
        approveBtn.addEventListener('click', async () => {
          const success = await updateQuestionFlag(q.id, true);
          if (success) {
            q.flagged = true;
            renderEditableQuestionsTable();
          }
        });

        // Reject button  
        const rejectBtn = document.createElement('button');
        rejectBtn.className = 'btn btn-sm btn-danger';
        rejectBtn.innerHTML = '‚úó Reject';
        rejectBtn.addEventListener('click', async () => {
          const success = await updateQuestionFlag(q.id, false);
          if (success) {
            q.flagged = false;
            renderEditableQuestionsTable();
          }
        });

        actTd.appendChild(approveBtn);
        actTd.appendChild(rejectBtn);
        tr.appendChild(actTd);

        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      // replace content
      resultsDiv.innerHTML = '';
      resultsDiv.appendChild(table);

      // wire select all checkbox
      const paperSelectAllToggle = document.getElementById('paperSelectAllToggle');
      if (paperSelectAllToggle) {
        paperSelectAllToggle.checked = PAPER_STATE.selectedIds.size === PAPER_STATE.loadedQuestions.length && PAPER_STATE.loadedQuestions.length > 0;
        
        paperSelectAllToggle.addEventListener('change', (ev) => {
          if (ev.target.checked) {
            PAPER_STATE.loadedQuestions.forEach(q => PAPER_STATE.selectedIds.add(q.id));
          } else {
            PAPER_STATE.selectedIds.clear();
          }
          // update all checkboxes in table
          table.querySelectorAll('.paper-select-row').forEach((c, i) => c.checked = ev.target.checked);
          updatePaperSummary();
        });
      }

      updatePaperSummary();
    }

   

    // Add search functionality    
    function initializeSearchFunctionality() {
  const searchInput = document.getElementById('searchInput');
  const questionTypeSelect = document.getElementById('questionTypeSelect');
  const difficultyFilter = document.getElementById('difficultyFilter');
  const pdfFilter = document.getElementById('pdfFilter'); // ADD THIS
  const searchBtn = document.getElementById('searchBtn');
  
  // Handle search button click
  if (searchBtn) {
    searchBtn.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      const searchTerm = searchInput ? searchInput.value : '';
      const questionType = questionTypeSelect ? questionTypeSelect.value : 'all';
      const difficulty = difficultyFilter ? difficultyFilter.value : 'all';
      const pdf = pdfFilter ? pdfFilter.value : ''; // ADD THIS
      
      loadQuestionsFromDB(searchTerm, questionType, difficulty, pdf);
    });
  }
  
  // Handle PDF filter change - ADD THIS
  if (pdfFilter) {
    pdfFilter.addEventListener('change', function() {
      const searchTerm = searchInput ? searchInput.value : '';
      const questionType = questionTypeSelect ? questionTypeSelect.value : 'all';
      const difficulty = difficultyFilter ? difficultyFilter.value : 'all';
      const pdf = this.value;
      
      loadQuestionsFromDB(searchTerm, questionType, difficulty, pdf);
    });
  }
  
  // Also trigger search when type changes
  if (questionTypeSelect) {
    questionTypeSelect.addEventListener('change', function() {
      const searchTerm = searchInput ? searchInput.value : '';
      const questionType = this.value;
      const difficulty = difficultyFilter ? difficultyFilter.value : 'all';
      const pdf = pdfFilter ? pdfFilter.value : ''; // ADD THIS
      
      loadQuestionsFromDB(searchTerm, questionType, difficulty, pdf);
    });
  }
  
  // Trigger search when difficulty changes
  if (difficultyFilter) {
    difficultyFilter.addEventListener('change', function() {
      const searchTerm = searchInput ? searchInput.value : '';
      const questionType = questionTypeSelect ? questionTypeSelect.value : 'all';
      const difficulty = this.value;
      const pdf = pdfFilter ? pdfFilter.value : ''; // ADD THIS
      
      loadQuestionsFromDB(searchTerm, questionType, difficulty, pdf);
    });
  }
  
  // Live search on input with debounce
  if (searchInput) {
    const doSearch = () => {
      const q = searchInput.value ? searchInput.value.trim() : '';
      const type = questionTypeSelect ? questionTypeSelect.value : 'all';
      const difficulty = difficultyFilter ? difficultyFilter.value : 'all';
      const pdf = pdfFilter ? pdfFilter.value : ''; // ADD THIS
      
      loadQuestionsFromDB(q, type, difficulty, pdf);
    };
    
    searchInput.addEventListener('input', debounce(doSearch, 300));
  }
    }


   
  // Global state for paper generation
const PAPER_GEN_STATE = {
    selectedPdfs: [],
    selectedTopics: [],
    availableQuestions: {},
    topicQuestionCounts: {}
};

// Load PDFs on page load
async function loadPaperPdfs() {
    try {
        const response = await fetch(`${backendBase}/questions`);
        const questions = await response.json();
        
        // Extract unique PDF names
        const pdfNames = [...new Set(questions.map(q => q.pdf_name).filter(name => name))];
        
        const pdfFilter = document.getElementById('paperPdfFilter');
        if (pdfFilter) {
            pdfFilter.innerHTML = pdfNames.length > 0 
                ? pdfNames.map(name => `<option value="${name}">${name}</option>`).join('')
                : '<option value="">No PDFs found</option>';
        }
        
        // Add change listener
        pdfFilter.addEventListener('change', handlePaperPdfSelection);
        
    } catch (error) {
        console.error('Error loading PDFs for paper generation:', error);
    }
}

// Handle PDF selection
async function handlePaperPdfSelection() {
    const pdfFilter = document.getElementById('paperPdfFilter');
    const selectedOptions = Array.from(pdfFilter.selectedOptions);
    PAPER_GEN_STATE.selectedPdfs = selectedOptions.map(opt => opt.value);
    
    if (PAPER_GEN_STATE.selectedPdfs.length === 0) {
        document.getElementById('paperTopicSelectionCard').style.display = 'none';
        document.getElementById('paperQuestionTypeCard').style.display = 'none';
        document.getElementById('paperGenerateButtonContainer').style.display = 'none';
        return;
    }
    
    // Load topics for selected PDFs
    await loadTopicsForSelectedPdfs();
    
    // Show topic selection card
    document.getElementById('paperTopicSelectionCard').style.display = 'block';
}

// Load topics for selected PDFs
async function loadTopicsForSelectedPdfs() {
    try {
        const response = await fetch(`${backendBase}/questions`);
        const allQuestions = await response.json();
        
        // Filter questions by selected PDFs and flagged=true
        const filteredQuestions = allQuestions.filter(q => 
            PAPER_GEN_STATE.selectedPdfs.includes(q.pdf_name) && q.flagged === true
        );
        
        // Extract unique topics
        const topics = [...new Set(filteredQuestions.map(q => q.topic).filter(t => t))];
        
        const topicsSelect = document.getElementById('paperTopicsSelect');
        const topicCount = document.getElementById('paperTopicCount');
        
        if (topicsSelect) {
            topicsSelect.innerHTML = topics.length > 0
                ? topics.map(topic => `<option value="${topic}">${topic}</option>`).join('')
                : '<option value="">No topics found</option>';
        }
        
        if (topicCount) {
            topicCount.textContent = `${topics.length} topics available`;
        }
        
        // Add change listener
        topicsSelect.addEventListener('change', handlePaperTopicSelection);
        
        // Setup select all/deselect all buttons
        document.getElementById('paperSelectAllTopics').onclick = () => {
            Array.from(topicsSelect.options).forEach(opt => opt.selected = true);
            handlePaperTopicSelection();
        };
        
        document.getElementById('paperDeselectAllTopics').onclick = () => {
            Array.from(topicsSelect.options).forEach(opt => opt.selected = false);
            handlePaperTopicSelection();
        };
        
    } catch (error) {
        console.error('Error loading topics:', error);
    }
}

// Handle topic selection
async function handlePaperTopicSelection() {
    const topicsSelect = document.getElementById('paperTopicsSelect');
    const selectedOptions = Array.from(topicsSelect.selectedOptions);
    PAPER_GEN_STATE.selectedTopics = selectedOptions.map(opt => opt.value);
    
    if (PAPER_GEN_STATE.selectedTopics.length === 0) {
        document.getElementById('paperQuestionTypeCard').style.display = 'none';
        document.getElementById('paperGenerateButtonContainer').style.display = 'none';
        return;
    }
    
    // Show question type card
    document.getElementById('paperQuestionTypeCard').style.display = 'block';
    
    // Load available questions for selected topics
    await loadAvailableQuestionsForTopics();
}

// Load available questions for selected topics and PDFs
async function loadAvailableQuestionsForTopics() {
    try {
        const response = await fetch(`${backendBase}/questions`);
        const allQuestions = await response.json();
        
        // Get question type filters
        const includeMCQ = document.getElementById('paperTypeMCQ').checked;
        const includeDesc = document.getElementById('paperTypeDescriptive').checked;
        
        // Filter questions
        const filteredQuestions = allQuestions.filter(q => 
            PAPER_GEN_STATE.selectedPdfs.includes(q.pdf_name) &&
            PAPER_GEN_STATE.selectedTopics.includes(q.topic) &&
            q.flagged === true &&
            ((includeMCQ && q.type === 'MCQ') || (includeDesc && q.type === 'Descriptive'))
        );
        
        // Count by difficulty
        const counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0};
        
        filteredQuestions.forEach(q => {
            if (q.difficulty) {
                const level = parseInt(q.difficulty);
                if (level >= 1 && level <= 5) {
                    counts[level]++;
                }
            }
        });
        
        PAPER_GEN_STATE.availableQuestions = counts;
        
        // Display available counts
        displayAvailableCounts(counts);
        
    } catch (error) {
        console.error('Error loading available questions:', error);
    }
}

// Display available question counts
function displayAvailableCounts(counts) {
    const infoDiv = document.getElementById('paperAvailableCountsInfo');
    const difficultyDiv = document.getElementById('paperDifficultySelection');
    const inputsContainer = document.getElementById('paperDifficultyInputs');
    
    const total = Object.values(counts).reduce((sum, count) => sum + count, 0);
    
    if (total === 0) {
        infoDiv.className = 'alert alert-warning';
        infoDiv.innerHTML = '<i class="bi bi-exclamation-triangle"></i> No approved questions available for selected filters';
        difficultyDiv.style.display = 'none';
        document.getElementById('paperGenerateButtonContainer').style.display = 'none';
        return;
    }
    
    infoDiv.className = 'alert alert-success';
    infoDiv.innerHTML = `
        <i class="bi bi-check-circle"></i> <strong>${total} approved questions available</strong>
        <div class="small mt-1">
            Level 1: ${counts[1]} | Level 2: ${counts[2]} | Level 3: ${counts[3]} | 
            Level 4: ${counts[4]} | Level 5: ${counts[5]}
        </div>
    `;
    
    // Show difficulty selection
    difficultyDiv.style.display = 'block';
    
    // Create inputs for available levels only
    inputsContainer.innerHTML = '';
    
    for (let level = 1; level <= 5; level++) {
        if (counts[level] > 0) {
            const col = document.createElement('div');
            col.className = 'col-md-4';
            col.innerHTML = `
                <label class="form-label">
                    Level ${level} 
                    <span class="badge bg-info">Available: ${counts[level]}</span>
                </label>
                <input type="number" id="paperLevel${level}Count" class="form-control" 
                       min="0" max="${counts[level]}" value="0">
            `;
            inputsContainer.appendChild(col);
            
            // Add validation
            const input = col.querySelector('input');
            input.addEventListener('input', function() {
                const value = parseInt(this.value) || 0;
                if (value > counts[level]) {
                    this.value = counts[level];
                    showNotification(`Cannot exceed ${counts[level]} questions for Level ${level}`, 'warning');
                }
                if (value < 0) {
                    this.value = 0;
                }
            });
        }
    }
    
    // Show generate button
    document.getElementById('paperGenerateButtonContainer').style.display = 'block';
}

// Add listeners for question type checkboxes
document.getElementById('paperTypeMCQ')?.addEventListener('change', () => {
    if (PAPER_GEN_STATE.selectedTopics.length > 0) {
        loadAvailableQuestionsForTopics();
    }
});

document.getElementById('paperTypeDescriptive')?.addEventListener('change', () => {
    if (PAPER_GEN_STATE.selectedTopics.length > 0) {
        loadAvailableQuestionsForTopics();
    }
});

// New generate function
async function generateQuestionPaperNew() {
    const statusEl = document.getElementById('paperGenerationStatus');
    const resultsDiv = document.getElementById('generatedPaperResults');
    
    // Collect selected difficulty counts
    const levels = {};
    let totalRequested = 0;
    
    for (let level = 1; level <= 5; level++) {
        const input = document.getElementById(`paperLevel${level}Count`);
        if (input) {
            const count = parseInt(input.value) || 0;
            levels[level] = count;
            totalRequested += count;
        }
    }
    
    if (totalRequested === 0) {
        statusEl.innerHTML = '<div class="alert alert-warning">Please request at least one question</div>';
        return;
    }
    
    // Get question types
    const types = {
        mcq: document.getElementById('paperTypeMCQ').checked,
        descriptive: document.getElementById('paperTypeDescriptive').checked
    };
    
    statusEl.innerHTML = '<div class="spinner-border spinner-border-sm"></div> Generating question paper...';
    
    try {
        const requestData = {
            levels: levels,
            types: types,
            topics: PAPER_GEN_STATE.selectedTopics,
            pdfs: PAPER_GEN_STATE.selectedPdfs
        };
        
        const response = await fetch(`${backendBase}/generate_question_paper`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestData)
        });
        
        const data = await response.json();
        
        if (data.status === 'success') {
            statusEl.innerHTML = `<div class="alert alert-success">‚úÖ Generated ${data.total_selected} questions</div>`;
            displayGeneratedPaper(data.questions, 'generatedPaperResults');
        } else {
            statusEl.innerHTML = `<div class="alert alert-danger">‚ùå Error: ${data.error}</div>`;
        }
        
    } catch (error) {
        console.error('Error generating paper:', error);
        statusEl.innerHTML = `<div class="alert alert-danger">‚ùå Error: ${error.message}</div>`;
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
    // Load when generatePaperPage is opened
    document.querySelectorAll('[data-page="generatePaperPage"]').forEach(btn => {
        btn.addEventListener('click', () => {
            setTimeout(loadPaperPdfs, 100);
        });
    });
});
 function cleanOptionText(optionText) {
    if (!optionText) return '';
    
    // More aggressive cleaning for question text
    let cleaned = optionText
        .replace(/\s*Answer:\s*[A-D][\s).]*/gi, '')  // Remove "Answer: A" etc.
        .replace(/\s*Difficulty:\s*\d+/gi, '')  // Remove "Difficulty: 4"
        .replace(/\s*Answer:\s*[A-D]\s*Difficulty:\s*\d+$/gi, '')
        .replace(/\s*Difficulty:\s*\d+\s*Answer:\s*[A-D]$/gi, '')
        .trim();
    
    // Also clean from the beginning of the text
    cleaned = cleaned.replace(/^Answer:\s*[A-D][\s).]*/gi, '');
    
    return cleaned;
}

  // Function to download question paper as text file
    function downloadQuestionPaper(questions) {
    if (!Array.isArray(questions)) questions = [];

    const mcqs = questions.filter(q => (q.type || '').toUpperCase() === 'MCQ');
    const descs = questions.filter(q => (q.type || '').toUpperCase() !== 'MCQ');
    const ordered = [...mcqs, ...descs];

    // Create Word document content with proper XML structure
    let wordContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <?mso-application progid="Word.Document"?>
    <w:wordDocument 
        xmlns:w="http://schemas.microsoft.com/office/word/2003/wordml"
        xmlns:v="urn:schemas-microsoft-com:vml"
        xmlns:w10="urn:schemas-microsoft-com:office:word"
        xmlns:sl="http://schemas.microsoft.com/schemaLibrary/2003/core"
        xmlns:aml="http://schemas.microsoft.com/aml/2001/core"
        xmlns:wx="http://schemas.microsoft.com/office/word/2003/auxHint"
        xmlns:o="urn:schemas-microsoft-com:office:office"
        xmlns:dt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882">
        
        <w:body>
            <wx:sect>
                <w:p>
                    <w:r>
                        <w:rPr>
                            <w:b/>
                            <w:sz w:val="32"/>
                            <w:sz-cs w:val="32"/>
                        </w:rPr>
                        <w:t>QUESTION PAPER</w:t>
                    </w:r>
                </w:p>
                <w:p>
                    <w:r>
                        <w:t>${'='.repeat(50)}</w:t>
                    </w:r>
                </w:p>
                <w:p><w:r><w:t></w:t></w:r></w:p>`;

        ordered.forEach((q, index) => {
            const cleanQuestion = cleanOptionText(q.question || '');
            
            // Question number and text
            wordContent += `
                <w:p>
                    <w:r>
                        <w:rPr>
                            <w:b/>
                        </w:rPr>
                        <w:t>${index + 1}. ${cleanQuestion}</w:t>
                    </w:r>
                </w:p>`;
            
            if ((q.type || '').toUpperCase() === 'MCQ') {
                // MCQ Options
                wordContent += `
                <w:p>
                    <w:r>
                        <w:t>   A) ${cleanOptionText(q.option_a || '')}</w:t>
                    </w:r>
                </w:p>
                <w:p>
                    <w:r>
                        <w:t>   B) ${cleanOptionText(q.option_b || '')}</w:t>
                    </w:r>
                </w:p>
                <w:p>
                    <w:r>
                        <w:t>   C) ${cleanOptionText(q.option_c || '')}</w:t>
                    </w:r>
                </w:p>
                <w:p>
                    <w:r>
                        <w:t>   D) ${cleanOptionText(q.option_d || '')}</w:t>
                    </w:r>
                </w:p>`;
            } else {
                // Descriptive question indicator
                wordContent += `
                <w:p>
                    <w:r>
                        <w:t>   [Descriptive Question]</w:t>
                    </w:r>
                </w:p>`;
            }
            
            // Add space between questions
            wordContent += `<w:p><w:r><w:t></w:t></w:r></w:p>`;
        });

        // Close the document
        wordContent += `
            </wx:sect>
        </w:body>
    </w:wordDocument>`;

        const blob = new Blob([wordContent], { 
            type: 'application/msword' 
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'question_paper.doc';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    
  
  </script>
  


  <footer class="mt-4" id="mainFooter">¬© 2025 ICFAI Group</footer>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Backend + Navigation Scripts -->
  <script>
     const backendBase = window.location.origin;
    // const backendBase = "https://transpulmonary-divergently-alfreda.ngrok-free.dev";

    let CURRENT_FACULTY = null;

    // Faculty login function
    async function facultyLogin() {
    const facultyId = document.getElementById('facultyId').value.trim();
    
    if (!facultyId) {
        showLoginError('Please enter Faculty User ID');
        return;
    }
    
    try {
        const response = await fetch(`${backendBase}/faculty_login`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ faculty_id: facultyId })
        });
        
        const data = await response.json();
        
        if (data.status === 'success' && data.authenticated) {
            // Store faculty info globally
            CURRENT_FACULTY = {
                id: facultyId,
                name: data.faculty_name || `Faculty ${facultyId}`,
                email: data.email || '',
                department: data.department || ''
            };
            
            // Hide login, show main page
            document.getElementById('loginPage').style.display = 'none';
            document.getElementById('mainPage').style.display = 'flex';
            document.getElementById('mainHeader').style.display = 'flex';
            document.getElementById('mainFooter').style.display = 'block';
            
            // REMOVED: Header update code
            
        } else {
            showLoginError(data.error || 'Invalid Faculty User ID');
        }
        
    } catch (error) {
        console.error('Login error:', error);
        showLoginError('Login failed. Please try again.');
    }
}

    function showLoginError(message) {
        const errorDiv = document.getElementById('loginError');
        errorDiv.textContent = `‚ö† ${message}`;
        errorDiv.style.display = 'block';
        
        // Hide success message if shown
        document.getElementById('loginSuccess').style.display = 'none';
    }

    // Logout function (update existing)
    function logout() {
        CURRENT_FACULTY = null;
        
        // Remove faculty badge from header if it exists
        const header = document.getElementById('mainHeader');
        if (header) {
            const facultyBadge = header.querySelector('.faculty-badge');
            if (facultyBadge) {
                facultyBadge.remove();
            }
        }
        
        document.getElementById('mainPage').style.display = 'none';
        document.getElementById('mainHeader').style.display = 'none';
        document.getElementById('mainFooter').style.display = 'none';
        document.getElementById('loginPage').style.display = 'flex';
        document.getElementById('facultyId').value = '';
        document.getElementById('loginError').style.display = 'none';
        document.getElementById('loginSuccess').style.display = 'none';
    }


  // Navigation - COMPLETE CORRECTED VERSION
  document.querySelectorAll('.nav-vertical .btn').forEach(btn => {
      btn.addEventListener('click', function() {
          const pageId = this.getAttribute('data-page');
          if (pageId) {
              console.log('Navigating to page:', pageId);
              document.querySelectorAll('.page').forEach(page => page.style.display = 'none');
              document.getElementById(pageId).style.display = 'block';
              
              if (pageId === 'questionsPage') {
                  console.log('‚òÖ Questions page opened');
                  
                  // Load faculty-specific filters FIRST
                  loadFacultyFilters().then(() => {
                      console.log('‚òÖ Filters loaded, now attaching program listener');
                      
                      // After filters are loaded, set up the program dropdown listener
                      const programFilter = document.getElementById('programFilter');
                      if (programFilter) {
                          console.log('‚òÖ Found programFilter element, attaching listener');
                          
                          // Remove any existing listeners (create new function reference each time)
                          const newHandler = function() {
                              const selectedProgram = this.value;
                              console.log('‚òÖ‚òÖ‚òÖ PROGRAM CHANGED TO:', selectedProgram);
                              
                              if (selectedProgram) {
                                  console.log('‚òÖ‚òÖ‚òÖ Calling loadProgramDetails for:', selectedProgram);
                                  loadProgramDetails(selectedProgram);
                              } else {
                                  console.log('‚òÖ‚òÖ‚òÖ No program selected, resetting dropdowns');
                                  // Reset other dropdowns if no program selected
                                  ['branchFilter', 'academicYearFilter', 'semesterFilter', 'courseFilter'].forEach(id => {
                                      const select = document.getElementById(id);
                                      if (select) {
                                          select.innerHTML = `<option value="">Select ${id.replace('Filter', '')}</option>`;
                                          select.disabled = true;
                                      }
                                  });
                              }
                          };
                          
                          // Remove old listener if exists
                          programFilter.removeEventListener('change', newHandler);
                          // Add new listener
                          programFilter.addEventListener('change', newHandler);
                          
                          console.log('‚òÖ Program dropdown listener attached successfully');
                      } else {
                          console.error('‚òÖ ERROR: programFilter element NOT FOUND!');
                      }
                  });

                   // ‚úÖ REFRESH PDF FILTER EVERY TIME PAGE IS OPENED
                loadFilterOptions().then(() => {
                    console.log('‚úÖ PDF filter refreshed');
                });
                  
                  // Load all questions initially (no filters applied)
                  const searchInput = document.getElementById('searchInput');
                  const questionTypeSelect = document.getElementById('questionTypeSelect');
                  const currentSearch = searchInput ? searchInput.value : '';
                  const currentType = questionTypeSelect ? questionTypeSelect.value : 'all';

                  // Load filter options (PDF list, years, semesters, etc.)
                  loadFilterOptions();           // <-- ADD THIS LINE
                  
                  loadQuestionsFromDB(currentSearch, currentType);
                  initializeSearchFunctionality();
              }
              if (pageId === 'generatePaperPage') {
              loadChaptersForPaper();
              initializeChapterSelection();
               // Add event listeners to difficulty inputs for real-time validation
              for (let level = 1; level <= 5; level++) {
                  const input = document.getElementById(`level${level}Count`);
                  if (input) {
                      input.addEventListener('input', async function() {
                          const counts = await loadAvailableQuestionCounts();
                          const available = counts[level] || 0;
                          const value = parseInt(this.value) || 0;
                          
                          if (value > available) {
                              this.value = available;
                              showNotification(`Cannot exceed ${available} available questions for Level ${level}`, 'warning');
                          }
                      });
                  }
              }

            }
            // ADD THIS: Handle course selection page
            if (pageId === 'courseSelectionPage') {
                console.log('‚òÖ Course Selection page opened');
                
                // Load faculty filters
                loadCourseSelectionFacultyFilters();
                
                // Initialize search functionality
                initializeCourseSelectionSearchFunctionality();
                
                // Load questions initially
                const searchInput = document.getElementById('courseSelectionSearchInput');
                const questionTypeSelect = document.getElementById('courseSelectionQuestionTypeSelect');
                // loadCourseSelectionQuestionsFromDB(
                //     searchInput ? searchInput.value : '',
                //     questionTypeSelect ? questionTypeSelect.value : 'all'
                // );
            }
          }
      });
  });
// Define the program change handler function separately
function handleProgramChange() {
    const selectedProgram = this.value;
    console.log('Program selected:', selectedProgram);
    
    if (selectedProgram) {
        loadProgramDetails(selectedProgram);
    } else {
        // Reset other dropdowns if no program selected
        ['branchFilter', 'academicYearFilter', 'semesterFilter', 'courseFilter'].forEach(id => {
            const select = document.getElementById(id);
            if (select) {
                select.innerHTML = `<option value="">Select ${id.replace('Filter', '')}</option>`;
                select.disabled = true;
            }
        });
    }
}
// Function to apply selected filters - UPDATED WITH COMPONENT
function applyFilters() {
    const program = document.getElementById('programFilter').value;
    const branch = document.getElementById('branchFilter').value;
    const year = document.getElementById('academicYearFilter').value;
    const semester = document.getElementById('semesterFilter').value;
    const course = document.getElementById('courseFilter').value;
    const component = document.getElementById('componentFilter').value;
    
    console.log('Filter values selected (informational only):', { 
        program, branch, year, semester, course, component 
    });
    
    // Show a notification about selected filters
    if (program || branch || year || semester || course || component) {
        const filterInfo = [];
        if (program) filterInfo.push(`Program: ${program}`);
        if (branch) filterInfo.push(`Branch: ${branch}`);
        if (year) filterInfo.push(`Year: ${year}`);
        if (semester) filterInfo.push(`Semester: ${semester}`);
        if (course) filterInfo.push(`Course: ${course}`);
        if (component) filterInfo.push(`Component: ${component}`);
        
        showNotification(`Filters selected: ${filterInfo.join(', ')}`, 'info');
    }
    
    // Load ALL questions regardless of dropdown selection
    const searchInput = document.getElementById('searchInput');
    const questionTypeSelect = document.getElementById('questionTypeSelect');
    const difficultyFilter = document.getElementById('difficultyFilter'); // ADD THIS
    
    loadQuestionsFromDB(
        searchInput ? searchInput.value : '',
        questionTypeSelect ? questionTypeSelect.value : 'all',
        difficultyFilter ? difficultyFilter.value : 'all' // ADD THIS
    );
}
  </script>

  <!-- Questions Page Functionality -->
  <script>
    // Function to load faculty-specific filter options
async function loadFacultyFilters() {
    if (!CURRENT_FACULTY) {
        console.error('No faculty logged in');
        return Promise.resolve();
    }
    
    try {
        console.log('Loading filters for faculty:', CURRENT_FACULTY.id);
        const response = await fetch(`${backendBase}/get_faculty_filters/${CURRENT_FACULTY.id}`);
        const data = await response.json();
        
        console.log('Faculty filters response:', data);
        
        if (data.error) {
            console.error('Error loading filters:', data.error);
            return Promise.resolve();
        }
        
        // Clear and populate Program dropdown
        const programFilter = document.getElementById('programFilter');
        if (programFilter) {
            programFilter.innerHTML = '<option value="">Select Program</option>';
            
            if (data.programs && data.programs.length > 0) {
                console.log('Populating programs:', data.programs);
                data.programs.forEach(program => {
                    const option = document.createElement('option');
                    option.value = program.id;
                    option.textContent = program.name; // Display name instead of ID
                    programFilter.appendChild(option);
                });
            } else {
                console.warn('No programs found for this faculty');
            }
        }
        
        // Reset other dropdowns
        ['branchFilter', 'academicYearFilter', 'semesterFilter', 'courseFilter'].forEach(id => {
            const select = document.getElementById(id);
            if (select) {
                select.innerHTML = `<option value="">Select ${id.replace('Filter', '')}</option>`;
                select.disabled = true;
            }
        });
        
        console.log('Faculty filters loaded successfully');
        return Promise.resolve();
        
    } catch (error) {
        console.error('Error loading faculty filters:', error);
        return Promise.resolve();
    }
}



// Function to load program-specific details - SIMPLIFIED AND CORRECTED
// Function to load program-specific details - WITH COMPONENT SUPPORT
async function loadProgramDetails(programId) {
    console.log('‚ñ∂‚ñ∂‚ñ∂ loadProgramDetails called with programId:', programId);
    
    if (!CURRENT_FACULTY) {
        console.error('‚ùå No CURRENT_FACULTY found');
        return;
    }
    
    if (!programId) {
        console.error('‚ùå No programId provided');
        return;
    }
    
    try {
        const url = `${backendBase}/get_program_details/${CURRENT_FACULTY.id}/${programId}`;
        console.log('‚ñ∂ Fetching from URL:', url);
        
        const response = await fetch(url);
        console.log('‚ñ∂ Response status:', response.status);
        
        if (!response.ok) {
            console.error('‚ùå Response not OK:', response.status);
            return;
        }
        
        const data = await response.json();
        console.log('‚ñ∂‚ñ∂‚ñ∂ RECEIVED DATA:', JSON.stringify(data, null, 2));
        
        if (data.error) {
            console.error('‚ùå API returned error:', data.error);
            alert('Error loading program details: ' + data.error);
            return;
        }
        // NEW: Load program outcomes for this program
        await loadProgramOutcomes(programId);

        
        // Populate Branch dropdown
        console.log('‚ñ∂ Populating Branch dropdown...');
        const branchFilter = document.getElementById('branchFilter');
        if (branchFilter) {
            branchFilter.innerHTML = '<option value="">All Branches</option>';
            branchFilter.disabled = false;
            
            if (data.branches && data.branches.length > 0) {
                data.branches.forEach(branch => {
                    const option = document.createElement('option');
                    option.value = branch.id;
                    option.textContent = branch.name;
                    branchFilter.appendChild(option);
                });
                console.log('‚úì‚úì‚úì Populated', data.branches.length, 'branches');
            }
        }
        
        // Populate Academic Year dropdown
        console.log('‚ñ∂ Populating Academic Year dropdown...');
        const academicYearFilter = document.getElementById('academicYearFilter');
        if (academicYearFilter) {
            academicYearFilter.innerHTML = '<option value="">All Years</option>';
            academicYearFilter.disabled = false;
            
            if (data.academic_years && data.academic_years.length > 0) {
                data.academic_years.forEach(year => {
                    const option = document.createElement('option');
                    option.value = year.id;
                    option.textContent = year.name;
                    academicYearFilter.appendChild(option);
                });
                console.log('‚úì‚úì‚úì Populated', data.academic_years.length, 'academic years');
            }
        }
        
        // Populate Semester dropdown
        console.log('‚ñ∂ Populating Semester dropdown...');
        const semesterFilter = document.getElementById('semesterFilter');
        if (semesterFilter) {
            semesterFilter.innerHTML = '<option value="">All Semesters</option>';
            semesterFilter.disabled = false;
            
            if (data.semesters && data.semesters.length > 0) {
                data.semesters.forEach(semester => {
                    const option = document.createElement('option');
                    option.value = semester.id;
                    option.textContent = semester.name;
                    semesterFilter.appendChild(option);
                });
                console.log('‚úì‚úì‚úì Populated', data.semesters.length, 'semesters');
            }
        }
        
        // Populate Course dropdown
        console.log('‚ñ∂ Populating Course dropdown...');
        const courseFilter = document.getElementById('courseFilter');
        if (courseFilter) {
            courseFilter.innerHTML = '<option value="">All Courses</option>';
            courseFilter.disabled = false;
            
            if (data.courses && data.courses.length > 0) {
                data.courses.forEach(course => {
                    const option = document.createElement('option');
                    option.value = course.id;
                    option.textContent = course.name;
                    courseFilter.appendChild(option);
                });
                console.log('‚úì‚úì‚úì Populated', data.courses.length, 'courses');
            }
            
            // ADD EVENT LISTENER FOR COURSE CHANGE TO LOAD COMPONENTS
            courseFilter.removeEventListener('change', handleCourseChange);
            courseFilter.addEventListener('change', handleCourseChange);
            console.log('‚úì Course dropdown listener attached');
        }
        
        // Reset Component dropdown
        const componentFilter = document.getElementById('componentFilter');
        if (componentFilter) {
            componentFilter.innerHTML = '<option value="">Select Component</option>';
            componentFilter.disabled = true;
        }
        
        console.log('‚úì‚úì‚úì ALL DROPDOWNS POPULATED SUCCESSFULLY ‚úì‚úì‚úì');
        
    } catch (error) {
        console.error('‚ùå‚ùå‚ùå EXCEPTION in loadProgramDetails:', error);
        alert('Error loading program details: ' + error.message);
    }
}


// Add these global variables to store PO/CO options
const PO_CO_STATE = {
    programOutcomes: [],
    courseOutcomes: [],
    selectedProgramId: null,
    selectedCourseId: null
};

// Function to load Program Outcomes
async function loadProgramOutcomes(programId) {
    if (!programId) {
        console.warn('No programId provided to loadProgramOutcomes');
        return;
    }
    
    try {
        console.log('üîµ Loading Program Outcomes for programId:', programId);
        const response = await fetch(`${backendBase}/get_program_outcomes/${programId}`);
        const data = await response.json();
        
        console.log('üîµ Program Outcomes response:', data);
        
        if (data.error) {
            console.error('‚ùå Error loading program outcomes:', data.error);
            PO_CO_STATE.programOutcomes = [];
            return;
        }
        
        PO_CO_STATE.programOutcomes = data.program_outcomes || [];
        PO_CO_STATE.selectedProgramId = programId;
        
        console.log('‚úÖ Program Outcomes loaded:', PO_CO_STATE.programOutcomes.length, 'outcomes');
        
        // If currently viewing questions page, reload the table to show new PO options
        const questionsPage = document.getElementById('questionsPage');
        if (questionsPage && questionsPage.style.display === 'block') {
            const searchInput = document.getElementById('searchInput');
            const questionTypeSelect = document.getElementById('questionTypeSelect');
            const currentSearch = searchInput ? searchInput.value : '';
            const currentType = questionTypeSelect ? questionTypeSelect.value : 'all';
            loadQuestionsFromDB(currentSearch, currentType);
        }
        
    } catch (error) {
        console.error('‚ùå Exception loading program outcomes:', error);
        PO_CO_STATE.programOutcomes = [];
    }
}

// Function to load Course Outcomes
async function loadCourseOutcomes(courseId) {
    if (!courseId) {
        console.warn('No courseId provided to loadCourseOutcomes');
        return;
    }
    
    try {
        console.log('üü¢ Loading Course Outcomes for courseId:', courseId);
        const response = await fetch(`${backendBase}/get_course_outcomes/${courseId}`);
        const data = await response.json();
        
        console.log('üü¢ Course Outcomes response:', data);
        
        if (data.error) {
            console.error('‚ùå Error loading course outcomes:', data.error);
            PO_CO_STATE.courseOutcomes = [];
            return;
        }
        
        PO_CO_STATE.courseOutcomes = data.course_outcomes || [];
        PO_CO_STATE.selectedCourseId = courseId;
        
        console.log('‚úÖ Course Outcomes loaded:', PO_CO_STATE.courseOutcomes.length, 'outcomes');
        
        // If currently viewing questions page, reload the table to show new CO options
        const questionsPage = document.getElementById('questionsPage');
        if (questionsPage && questionsPage.style.display === 'block') {
            const searchInput = document.getElementById('searchInput');
            const questionTypeSelect = document.getElementById('questionTypeSelect');
            const currentSearch = searchInput ? searchInput.value : '';
            const currentType = questionTypeSelect ? questionTypeSelect.value : 'all';
            loadQuestionsFromDB(currentSearch, currentType);
        }
        
    } catch (error) {
        console.error('‚ùå Exception loading course outcomes:', error);
        PO_CO_STATE.courseOutcomes = [];
    }
}

// Update handleCourseChange to load outcomes when course is selected
function handleCourseChange() {
    const selectedCourse = this.value;
    console.log('‚òÖ‚òÖ‚òÖ COURSE CHANGED TO:', selectedCourse);
    
    if (selectedCourse) {
        loadComponents(selectedCourse);
        loadCourseOutcomes(selectedCourse);  // NEW: Load course outcomes
    } else {
        const componentFilter = document.getElementById('componentFilter');
        if (componentFilter) {
            componentFilter.innerHTML = '<option value="">Select Component</option>';
            componentFilter.disabled = true;
        }
        PO_CO_STATE.courseOutcomes = [];
    }
}


// Function to load components for selected course
async function loadComponents(courseId) {
    console.log('‚ñ∂‚ñ∂‚ñ∂ loadComponents called with courseId:', courseId);
    
    if (!courseId) {
        console.error('‚ùå No courseId provided');
        return;
    }
    
    try {
        const url = `${backendBase}/get_components/${courseId}`;
        console.log('‚ñ∂ Fetching components from URL:', url);
        
        const response = await fetch(url);
        console.log('‚ñ∂ Response status:', response.status);
        
        if (!response.ok) {
            console.error('‚ùå Response not OK:', response.status);
            return;
        }
        
        const data = await response.json();
        console.log('‚ñ∂‚ñ∂‚ñ∂ RECEIVED COMPONENT DATA:', JSON.stringify(data, null, 2));
        
        if (data.error) {
            console.error('‚ùå API returned error:', data.error);
            return;
        }
        
        // Populate Component dropdown
        console.log('‚ñ∂ Populating Component dropdown...');
        const componentFilter = document.getElementById('componentFilter');
        if (componentFilter) {
            componentFilter.innerHTML = '<option value="">All Components</option>';
            componentFilter.disabled = false;
            
            if (data.components && data.components.length > 0) {
                data.components.forEach(component => {
                    const option = document.createElement('option');
                    option.value = component;
                    option.textContent = component;
                    componentFilter.appendChild(option);
                });
                console.log('‚úì‚úì‚úì Populated', data.components.length, 'components');
            } else {
                console.warn('‚ö† No components found for this course');
                componentFilter.innerHTML = '<option value="">No Components</option>';
            }
        } else {
            console.error('‚ùå componentFilter element NOT FOUND!');
        }
        
        console.log('‚úì‚úì‚úì COMPONENT DROPDOWN POPULATED SUCCESSFULLY ‚úì‚úì‚úì');
        
    } catch (error) {
        console.error('‚ùå‚ùå‚ùå EXCEPTION in loadComponents:', error);
    }
}
       function initializeQuestionTableEventListeners() {
    // Existing editable field listeners
    document.querySelectorAll('#questionsTable .editable').forEach(element => {
        element.addEventListener('blur', function() {
            const questionId = this.getAttribute('data-id');
            const field = this.getAttribute('data-field');
            const value = this.innerText.trim();
            
            if (questionId && field) {
                updateQuestionField(questionId, field, value);
            }
        });
        
        element.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.blur();
            }
        });
    });
    
    // Difficulty select listeners
    document.querySelectorAll('#questionsTable .difficulty-select').forEach(select => {
        select.addEventListener('change', function() {
            const questionId = this.getAttribute('data-id');
            const value = this.value;
            
            if (questionId) {
                updateQuestionField(questionId, 'difficulty', value);
            }
        });
    });
    
    
    // Approve button listeners
     document.querySelectorAll('#questionsTable .approve-btn').forEach(button => {
        button.addEventListener('click', function() {
            const questionId = this.getAttribute('data-id');
            if (questionId) {
                // Show confirmation dialog
                if (confirm('Are you sure you want to APPROVE this question?')) {
                    updateQuestionFlag(questionId, true);
                }
            }
        });
    });
    
    // Reject button listeners
    document.querySelectorAll('#questionsTable .reject-btn').forEach(button => {
        button.addEventListener('click', function() {
            const questionId = this.getAttribute('data-id');
            if (questionId) {
                // Show confirmation dialog
                if (confirm('Are you sure you want to REJECT this question?')) {
                    updateQuestionFlag(questionId, false);
                }
            }
        });
    });
}
    async function loadQuestionsFromDB(searchTerm = '', questionType = '', difficulty = '', pdf = '') {
      console.log('loadQuestionsFromDB called with:', { searchTerm, questionType, difficulty, pdf });
      
      const questionsTable = document.getElementById('questionsTable');
      const questionsCount = document.getElementById('questionsCount');
      
      questionsTable.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div><p>Loading questions...</p></div>';
      
      try {
        let url = `${backendBase}/questions`;
        const params = new URLSearchParams();
        
        if (searchTerm && searchTerm.trim() !== '') {
          params.append('search', searchTerm.trim());
        }
        
        if (questionType && questionType !== 'all') {
          params.append('qtype', questionType);
        }
        
        // PDF filter - pass as 'pdf' parameter
        if (pdf) {
          params.append('pdf', pdf);
        }
        
        // Difficulty filter
        if (difficulty && difficulty !== 'all') {
          params.append('difficulty', difficulty);
        }
        
        if (params.toString()) {
          url += '?' + params.toString();
        }
        
        console.log('Final URL:', url);
        
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const questions = await response.json();
        
        questionsCount.innerHTML = `<div class="alert alert-info">Found ${questions.length} questions</div>`;
        
        if (questions.length === 0) {
            questionsTable.innerHTML = '<div class="alert alert-warning text-center">No questions found in the database.</div>';
            return;
        }
        
        // Create table with PO and CO columns
        let tableHTML = `
        <div style="max-height: 500px; overflow-y: auto;">
          <table class="table table-striped table-hover">
            <thead class="table-light sticky-top">
              <tr>
                <th>ID</th>
                <th>Topic</th>
                <th>Type</th>
                <th>Question</th>
                <th>Options/Answer</th>
                <th>Difficulty</th>
                
                <th>PDF</th>
                <th>Flagged</th>
                <th>Actions</th>
                <th>Created</th>
              </tr>
            </thead>
            <tbody>
        `;
        
        questions.forEach(q => {
            const createdDate = q.created_at ? new Date(q.created_at).toLocaleDateString() : 'N/A';
            let optionsHtml = '';
            
            if (q.type === 'MCQ') {
                optionsHtml = `
                  <div><strong>A:</strong> <span class="editable" contenteditable="true" data-field="option_a" data-id="${q.id}">${q.option_a || ''}</span></div>
                  <div><strong>B:</strong> <span class="editable" contenteditable="true" data-field="option_b" data-id="${q.id}">${q.option_b || ''}</span></div>
                  <div><strong>C:</strong> <span class="editable" contenteditable="true" data-field="option_c" data-id="${q.id}">${q.option_c || ''}</span></div>
                  <div><strong>D:</strong> <span class="editable" contenteditable="true" data-field="option_d" data-id="${q.id}">${q.option_d || ''}</span></div>
                  <div class="text-success"><strong>Answer:</strong> <span class="editable" contenteditable="true" data-field="answer" data-id="${q.id}">${q.answer || ''}</span></div>
                `;
            } else {
                optionsHtml = `
                  <div class="text-success">
                    <strong>Answer:</strong> 
                    <span class="editable" contenteditable="true" data-field="descriptive_answer" data-id="${q.id}">
                      ${q.descriptive_answer || 'Not provided'}
                    </span>
                  </div>
                `;
            }
            
            const flaggedStatus = q.flagged === true ? 
                '<span class="badge bg-success">Approved</span>' : 
                q.flagged === false ? 
                '<span class="badge bg-danger">Not Approved</span>' : 
                '<span class="badge bg-secondary">Pending</span>';
            
            // DEBUG: Log PO/CO state for first question only
            if (questions.indexOf(q) === 0) {
                console.log('üìä Rendering table with PO/CO state:', {
                    programOutcomes: PO_CO_STATE.programOutcomes.length,
                    courseOutcomes: PO_CO_STATE.courseOutcomes.length,
                    question_po_id: q.po_id,
                    question_co_id: q.co_id
                });
            }
            
            tableHTML += `
              <tr class="question-row ${(q.type || '').toLowerCase()}">
                <td>${q.id}</td>
                <td>
                  <span class="editable" contenteditable="true" data-field="topic" data-id="${q.id}">
                    ${q.topic || 'N/A'}
                  </span>
                </td>
                <td><span class="badge ${q.type === 'MCQ' ? 'bg-success' : 'bg-warning'}">${q.type || 'Unknown'}</span></td>
                <td>
                  <span class="editable" contenteditable="true" data-field="question" data-id="${q.id}">
                    ${q.question || ''}
                  </span>
                </td>
                <td>${optionsHtml}</td>
                <td>
                  <select class="form-select form-select-sm difficulty-select" data-id="${q.id}">
                    <option value="">‚Äî</option>
                    ${[1,2,3,4,5].map(i => `<option value="${i}" ${q.difficulty == i ? 'selected' : ''}>${i}</option>`).join('')}
                  </select>
                </td>
                
                <td>${q.pdf_name ? q.pdf_name : ''}</td>   <!-- <- PDF cell -->
                <td>${flaggedStatus}</td>
                <td>
                  <div class="btn-group btn-group-sm">
                    <button class="btn btn-success approve-btn" data-id="${q.id}" title="Approve Question" ${q.flagged === true ? 'disabled' : ''}>
                      ‚úì
                    </button>
                    <button class="btn btn-danger reject-btn" data-id="${q.id}" title="Reject Question" ${q.flagged === false ? 'disabled' : ''}>
                      ‚úó
                    </button>
                  </div>
                </td>
                <td>${createdDate}</td>
              </tr>
            `;
        });
        
        tableHTML += '</tbody></table></div>';
        questionsTable.innerHTML = tableHTML;
        
        initializeQuestionTableEventListeners();
        
    } catch (error) {
        console.error('Error loading questions:', error);
        questionsTable.innerHTML = '<div class="alert alert-danger">Error loading questions from database: ' + error.message + '</div>';
    }
}

// Function to update individual question field
async function updateQuestionField(questionId, field, value) {
    try {
        const response = await fetch(`${backendBase}/update_question`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                id: parseInt(questionId),
                updates: {
                    [field]: value
                }
            })
        });
        
        const data = await response.json();
        if (data.status === 'success') {
            console.log(`‚úÖ Question ${questionId} ${field} updated successfully`);
            showNotification(`Question ${field} updated successfully`, 'success');
            return true;
        } else {
            console.error('‚ùå Failed to update question:', data.error);
            showNotification(`Failed to update question: ${data.error}`, 'error');
            return false;
        }
    } catch (error) {
        console.error('‚ùå Error updating question:', error);
        showNotification('Error updating question. Please try again.', 'error');
        return false;
    }
}

// Function to update question flag (approve/reject)
// Function to update question flag (approve/reject) - UPDATED VERSION
async function updateQuestionFlag(questionId, flagged) {
  try {
    // Capture current filter state BEFORE updating
    const searchInput = document.getElementById('searchInput');
    const questionTypeSelect = document.getElementById('questionTypeSelect');
    const difficultyFilter = document.getElementById('difficultyFilter');
    const pdfFilter = document.getElementById('pdfFilter');
    
    const currentSearch = searchInput ? searchInput.value : '';
    const currentType = questionTypeSelect ? questionTypeSelect.value : 'all';
    const currentDifficulty = difficultyFilter ? difficultyFilter.value : 'all';
    const currentPdf = pdfFilter ? pdfFilter.value : '';
    
    const response = await fetch(`${backendBase}/update_question`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        id: parseInt(questionId),
        updates: {
          flagged: flagged
        }
      })
    });
    
    const data = await response.json();
    if (data.status === 'success') {
      // Reload questions WITH CURRENT FILTERS
      loadQuestionsFromDB(currentSearch, currentType, currentDifficulty, currentPdf);
      showNotification(`Question ${flagged ? 'approved' : 'rejected'} successfully`, 'success');
    } else {
      console.error('Failed to update question flag:', data.error);
      showNotification(`Failed to update question: ${data.error}`, 'error');
    }
  } catch (error) {
    console.error('Error updating question flag:', error);
    showNotification('Error updating question status. Please try again.', 'error');
  }
}
// debounce helper
  function debounce(fn, wait = 300) {
    let t;
    return function(...args) {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), wait);
    };
  }

  // ensure the search input triggers filtered loads on typing
  (function wireLiveSearch() {
    const searchInput = document.getElementById('searchInput');
    const questionTypeSelect = document.getElementById('questionTypeSelect');
    const difficultyFilter = document.getElementById('difficultyFilter'); // ADD THIS
    const searchBtn = document.getElementById('searchBtn');

    if (!searchInput) return;

    const doSearch = () => {
      const q = searchInput.value ? searchInput.value.trim() : '';
      const type = (questionTypeSelect && questionTypeSelect.value) ? questionTypeSelect.value : 'all';
      const difficulty = (difficultyFilter && difficultyFilter.value) ? difficultyFilter.value : 'all'; // ADD THIS
      loadQuestionsFromDB(q, type, difficulty);
    };

    // live search on input with debounce
    searchInput.addEventListener('input', debounce(doSearch, 300));

    // also update when question type changes
    if (questionTypeSelect) {
      questionTypeSelect.addEventListener('change', () => {
        // run with current search text
        const q = searchInput.value ? searchInput.value.trim() : '';
        loadQuestionsFromDB(q, questionTypeSelect.value);
      });

    }
    // ADD: Update when difficulty changes
    if (difficultyFilter) {
        difficultyFilter.addEventListener('change', () => {
            const q = searchInput.value ? searchInput.value.trim() : '';
            const type = (questionTypeSelect && questionTypeSelect.value) ? questionTypeSelect.value : 'all';
            const difficulty = difficultyFilter.value;
            loadQuestionsFromDB(q, type, difficulty);
        });
    }
    // keep the manual search button (if present) wired
    if (searchBtn) {
      searchBtn.addEventListener('click', (e) => {
        e.preventDefault();
        doSearch();
      });
    }
  })();

  </script>
  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script> -->

  <script>

    function displayGeneratedPaper(questions, targetElementId = 'generatedPaperResults') {
    const resultsDiv = document.getElementById(targetElementId);
    if (!resultsDiv) {
        console.error('Target element not found:', targetElementId);
        return;
    }
    resultsDiv.innerHTML = '';

    if (!questions || questions.length === 0) {
        resultsDiv.innerHTML = '<div class="alert alert-warning">No questions found.</div>';
        return;
    }

    // Shuffle MCQ options
    const processedQuestions = questions.map(q => {
        if (q.type === 'MCQ') {
            return shuffleMCQOptions(q);
        }
        return q;
    });

    const mcqs = processedQuestions.filter(q => (q.type || '').toUpperCase() === 'MCQ');
    const descs = processedQuestions.filter(q => (q.type || '').toUpperCase() !== 'MCQ');

    const paperContainer = document.createElement('div');
    paperContainer.className = 'question-paper';

    const header = document.createElement('h5');
    header.className = 'mb-3 text-primary';
    header.textContent = `Generated Question Paper (${questions.length} questions) - OPTIONS SHUFFLED`;
    paperContainer.appendChild(header);

    // If there are MCQs, render them first
    if (mcqs.length) {
        const mcqSection = document.createElement('div');
        mcqSection.className = 'mb-3';
        mcqSection.innerHTML = `<h6>Multiple Choice Questions (${mcqs.length}) - Options Shuffled</h6>`;
        
        const table = document.createElement('table');
        table.className = 'table table-bordered table-striped question-paper w-100 mb-3';
        table.style.tableLayout = 'fixed';
        let tableHTML = `<thead class="table-dark"><tr><th width="5%">#</th><th width="60%">Question</th><th width="35%">Options</th></tr></thead><tbody>`;
        
        mcqs.forEach((q, i) => {
            // Use the already formatted options with new labels
            const cleanA = cleanOptionText(q.option_a || '');
            const cleanB = cleanOptionText(q.option_b || '');
            const cleanC = cleanOptionText(q.option_c || '');
            const cleanD = cleanOptionText(q.option_d || '');
            
            tableHTML += `<tr><td><strong>${i+1}</strong></td><td>${q.question}</td><td>
                <div><strong>A:</strong> ${cleanA}</div>
                <div><strong>B:</strong> ${cleanB}</div>
                <div><strong>C:</strong> ${cleanC}</div>
                <div><strong>D:</strong> ${cleanD}</div>
            </td></tr>`;
        });
        tableHTML += '</tbody>';
        table.innerHTML = tableHTML;
        mcqSection.appendChild(table);
        paperContainer.appendChild(mcqSection);
    }

    // Rest of your display code remains the same...
    // Then descriptive questions
    if (descs.length) {
        const descSection = document.createElement('div');
        descSection.className = 'mb-3';
        descSection.innerHTML = `<h6>Descriptive / Short-answer Questions (${descs.length})</h6>`;
        
        const table = document.createElement('table');
        table.className = 'table table-bordered table-striped question-paper w-100';
        table.style.tableLayout = 'fixed';
        let tableHTML = `<thead class="table-dark"><tr><th width="5%">#</th><th width="95%">Question</th></tr></thead><tbody>`;
        descs.forEach((q, i) => {
            tableHTML += `<tr><td><strong>${i+1}</strong></td><td>${q.question}</td></tr>`;
        });
        tableHTML += '</tbody>';
        table.innerHTML = tableHTML;
        descSection.appendChild(table);
        paperContainer.appendChild(descSection);
    }

    // Download button
    const downloadBtn = document.createElement('button');
    downloadBtn.className = 'btn btn-success mt-3';
    downloadBtn.innerHTML = 'üì• Download Question Paper';
    downloadBtn.onclick = () => downloadQuestionPaper(processedQuestions);
    paperContainer.appendChild(downloadBtn);

    resultsDiv.appendChild(paperContainer);
}

  // Function to shuffle an array (Fisher-Yates algorithm)
  function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
  }

  // Function to remove existing option labels (A., B., C., D.)
  function removeOptionLabel(optionText) {
      if (!optionText) return '';
      // Remove patterns like "A. ", "B) ", "C:", "D - " etc.
      return optionText.replace(/^[A-D][\.\:\-\)]\s*/, '').trim();
  }

  // Function to shuffle MCQ options while preserving the correct answer
  function shuffleMCQOptions(question) {
      if (question.type !== 'MCQ') return question;
      
      // Create options with cleaned text (without labels)
      const options = [
          { label: 'A', text: removeOptionLabel(question.option_a || '') },
          { label: 'B', text: removeOptionLabel(question.option_b || '') },
          { label: 'C', text: removeOptionLabel(question.option_c || '') },
          { label: 'D', text: removeOptionLabel(question.option_d || '') }
      ].filter(opt => opt.text.trim() !== ''); // Remove empty options
      
      // Shuffle the options
      const shuffledOptions = shuffleArray(options);
      
      // Find the new position of the correct answer
      const originalAnswer = question.answer;
      let newAnswer = '';
      
      shuffledOptions.forEach((option, index) => {
          if (option.label === originalAnswer) {
              newAnswer = ['A', 'B', 'C', 'D'][index];
          }
      });
      
      // Create the shuffled question with new labels
      return {
          ...question,
          option_a: `A. ${shuffledOptions[0]?.text || ''}`,
          option_b: `B. ${shuffledOptions[1]?.text || ''}`,
          option_c: `C. ${shuffledOptions[2]?.text || ''}`,
          option_d: `D. ${shuffledOptions[3]?.text || ''}`,
          answer: newAnswer,
          original_answer: originalAnswer, // Keep original for reference
          options_shuffled: true // Flag to indicate options were shuffled
      };
  }
  

// ========== COURSE SELECTION PAGE FUNCTIONS ==========

// 1. PDF Upload Functions for Course Selection Page
// ========== COURSE SELECTION PDF FUNCTIONALITY (COMPLETE ISOLATED VERSION) ==========

// Course Selection PDF Upload Functions
(function initCourseSelectionPdf() {
    const pdfInput = document.querySelector('#courseSelectionPage #courseSelectionPdfUploader');
    const pdfBox = pdfInput && pdfInput.closest('.upload-box');
    const statNodes = {
        pdfUploads: document.getElementById('courseSelectionPdfUploadsStat'),
        pages: document.getElementById('courseSelectionPagesStat'),
        mcq: document.getElementById('courseSelectionMcqStat'),
        desc: document.getElementById('courseSelectionDescStat')
    };
        // ========== ADD THIS MODAL HTML HERE ==========
    const courseSelectionConfirmationModal = document.createElement('div');
    courseSelectionConfirmationModal.className = 'modal fade';
    courseSelectionConfirmationModal.id = 'courseSelectionPdfConfirmationModal';
    courseSelectionConfirmationModal.innerHTML = `
      <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title"><i class="bi bi-file-earmark-check"></i> Confirm PDF Upload & Select Topics</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
          </div>
          <!-- PDF Preview Section (First) -->
          <div class="mb-4">
            <div class="border rounded p-3" style="background-color: #f8f9fa;">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="mb-0"><i class="bi bi-file-pdf"></i> PDF Preview (Scroll to view all pages)</h6>
                <span class="badge bg-primary" id="courseSelectionPdfPageCount">Loading...</span>
              </div>
              <div id="courseSelectionPdfScrollContainer" style="max-height: 600px; overflow-y: auto; background: #e9ecef; border: 2px solid #dee2e6; border-radius: 5px; padding: 10px;">
                <div id="courseSelectionPdfPagesContainer" style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                  <div class="text-center py-5">
                    <div class="spinner-border text-primary" role="status"></div>
                    <p class="mt-2">Loading PDF...</p>
                  </div>
                </div>
              </div>
              <div class="small text-muted mt-2">
                <i class="bi bi-info-circle"></i> Scroll through the PDF preview above to review content before selecting topics
              </div>
            </div>
          </div>
          <div class="modal-body">
            <div id="courseSelectionPdfInfo"></div>
            <div id="courseSelectionModalTopicsContainer" style="display:none;">
              <hr class="my-3">
              <h6><i class="bi bi-tags"></i> Select Topics:</h6>
              <div class="d-flex justify-content-between align-items-center mb-2">
                <span class="small text-muted" id="courseSelectionModalSelectedCount">0 topics selected</span>
                <div>
                  <button type="button" id="courseSelectionModalSelectAll" class="btn btn-sm btn-outline-primary me-1">
                    <i class="bi bi-check-square"></i> Select All
                  </button>
                  <button type="button" id="courseSelectionModalDeselectAll" class="btn btn-sm btn-outline-secondary">
                    <i class="bi bi-square"></i> Deselect All
                  </button>
                </div>
              </div>
              <div id="courseSelectionModalTopicsList" style="max-height: 300px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 5px; padding: 10px; background-color: #f8f9fa;">
              </div>
            </div>
            <div class="alert alert-info mt-2" id="courseSelectionModalInfoMessage">
              <i class="bi bi-info-circle"></i> Analyzing PDF to extract topics...
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-primary" id="courseSelectionConfirmContinueBtn" disabled>
              <i class="bi bi-check-lg"></i> Continue
            </button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(courseSelectionConfirmationModal);
     async function loadCourseSelectionPDF(file) {
      try {
        console.log('üìÑ Starting to load PDF for course selection:', file.name);
        const arrayBuffer = await file.arrayBuffer();
        const pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        
        console.log(`üìÑ Course Selection PDF loaded successfully: ${pdfDoc.numPages} pages`);
        
        await renderCourseSelectionPDFPages(pdfDoc);
        return pdfDoc;
      } catch (error) {
        console.error('Error loading PDF for course selection:', error);
        const container = document.getElementById('courseSelectionPdfPagesContainer');
        if (container) {
          container.innerHTML = `
            <div class="alert alert-danger m-3">
              <i class="bi bi-exclamation-triangle"></i> Error loading PDF: ${error.message}
            </div>
          `;
        }
        return null;
      }
    }

    // Function to render all PDF pages for course selection
    async function renderCourseSelectionPDFPages(pdfDoc) {
      try {
        const container = document.getElementById('courseSelectionPdfPagesContainer');
        const scrollContainer = document.getElementById('courseSelectionPdfScrollContainer');
        const pageCountBadge = document.getElementById('courseSelectionPdfPageCount');
        
        if (!container) {
          console.error('courseSelectionPdfPagesContainer element not found');
          return;
        }
        
        console.log(`Starting to render ${pdfDoc.numPages} pages for course selection`);
        
        container.innerHTML = '';
        
        if (pageCountBadge) {
          pageCountBadge.textContent = `${pdfDoc.numPages} pages`;
        }
        
        const containerWidth = scrollContainer ? (scrollContainer.clientWidth - 40) : 600;
        
        // Render each page
        for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
          const page = await pdfDoc.getPage(pageNum);
          
          const canvas = document.createElement('canvas');
          canvas.className = 'pdf-page-canvas';
          canvas.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
          canvas.style.backgroundColor = 'white';
          canvas.style.maxWidth = '100%';
          canvas.style.height = 'auto';
          
          const ctx = canvas.getContext('2d');
          
          const viewport = page.getViewport({ scale: 1 });
          const scale = Math.min(containerWidth / viewport.width, 2.5);
          const scaledViewport = page.getViewport({ scale: scale });
          
          canvas.height = scaledViewport.height;
          canvas.width = scaledViewport.width;
          
          const pageWrapper = document.createElement('div');
          pageWrapper.style.position = 'relative';
          pageWrapper.style.width = '100%';
          pageWrapper.style.display = 'flex';
          pageWrapper.style.flexDirection = 'column';
          pageWrapper.style.alignItems = 'center';
          
          const pageLabel = document.createElement('div');
          pageLabel.className = 'badge bg-secondary mb-2';
          pageLabel.textContent = `Page ${pageNum}`;
          pageWrapper.appendChild(pageLabel);
          pageWrapper.appendChild(canvas);
          
          container.appendChild(pageWrapper);
          
          const renderContext = {
            canvasContext: ctx,
            viewport: scaledViewport
          };
          
          await page.render(renderContext).promise;
          
          if (pageNum % 3 === 0) {
            await new Promise(resolve => setTimeout(resolve, 10));
          }
        }
        
        console.log(`‚úÖ Successfully rendered ${pdfDoc.numPages} pages for course selection`);
        
      } catch (error) {
        console.error('Error rendering PDF pages for course selection:', error);
        const container = document.getElementById('courseSelectionPdfPagesContainer');
        if (container) {
          container.innerHTML = `
            <div class="alert alert-danger m-3">
              <i class="bi bi-exclamation-triangle"></i> Error loading PDF preview: ${error.message}
            </div>
          `;
        }
      }
    }


    function updateDashboardFromResponse(resp) {
        try {
            if (!resp) return;
            if (statNodes.pdfUploads) statNodes.pdfUploads.textContent = (resp.global_state?.pdf_uploads ?? statNodes.pdfUploads.textContent);
            if (statNodes.pages) statNodes.pages.textContent = (typeof resp.pages === 'number' ? resp.pages : (resp.global_state?.last_pdf_pages ?? statNodes.pages.textContent));
            if (statNodes.mcq) statNodes.mcq.textContent = (typeof resp.mcqCount === 'number') ? resp.mcqCount : statNodes.mcq.textContent;
            if (statNodes.desc) statNodes.desc.textContent = (typeof resp.descCount === 'number') ? resp.descCount : statNodes.desc.textContent;
        } catch (e) {
            console.warn("Failed to update course selection dashboard:", e);
        }
    }

    if (!pdfInput || !pdfBox) return;

    // Build controls area under upload box
    const ctrlWrap = document.createElement('div');
    ctrlWrap.className = 'mt-3';
    pdfBox.appendChild(ctrlWrap);

    const statusEl = document.createElement('div'); 
    statusEl.style.marginTop = '8px'; 
    ctrlWrap.appendChild(statusEl);
    
    const tocEl = document.createElement('div'); 
    tocEl.style.marginTop = '8px'; 
    ctrlWrap.appendChild(tocEl);

    // Time estimation display
    const timeEstimateEl = document.createElement('div');
    timeEstimateEl.className = 'mt-2';
    timeEstimateEl.id = 'courseSelectionTimeEstimate';
    timeEstimateEl.style.display = 'none';
    timeEstimateEl.innerHTML = `
        <div class="alert alert-warning p-2">
            <div class="d-flex align-items-center">
                <i class="bi bi-clock me-2"></i>
                <div>
                    <strong>Estimated Time:</strong> <span id="courseSelectionEstimatedTimeText">Calculating...</span>
                    <div class="small text-muted" id="courseSelectionTimeDetails"></div>
                </div>
            </div>
        </div>
    `;
    ctrlWrap.appendChild(timeEstimateEl);

    // Options form - FOR COURSE SELECTION PAGE
    const optionsForm = document.createElement('div');
    optionsForm.id = 'courseSelectionOptionsForm';
    optionsForm.style.display = 'none';
    optionsForm.innerHTML = `
        <div class="row g-2 align-items-center mt-3">
            <div class="col-md-4">
                <label class="form-label mb-0"><i class="bi bi-list-check"></i> Question Type</label>
                <select id="courseSelectionQuestionType" class="form-select">
                    <option value="mcq">MCQs Only</option>
                    <option value="descriptive">Descriptive Only</option>
                    <option value="both" selected>Both MCQs & Descriptive</option>
                </select>
            </div>
            <div class="col-md-4" id="courseSelectionMcqInputContainer">
                <label class="form-label mb-0"><i class="bi bi-question-circle"></i> MCQs per Topic</label>
                <input id="courseSelectionNumMcqs" type="number" min="1" max="50" value="0" 
                       class="form-control" placeholder="Enter number (1-50)">
                <div class="invalid-feedback">Please enter a valid number (1-50)</div>
            </div>
            <div class="col-md-4" id="courseSelectionDescInputContainer">
                <label class="form-label mb-0"><i class="bi bi-pencil"></i> Descriptive per Topic</label>
                <input id="courseSelectionNumDesc" type="number" min="1" max="20" value="0" 
                       class="form-control" placeholder="Enter number (1-20)">
                <div class="invalid-feedback">Please enter a valid number (1-20)</div>
            </div>
        </div>
    `;
    ctrlWrap.appendChild(optionsForm);

    // Topics selection container
    const topicsContainer = document.createElement('div');
    topicsContainer.className = 'mt-3';
    topicsContainer.id = 'courseSelectionTopicsContainer';
    topicsContainer.style.display = 'none';
    ctrlWrap.appendChild(topicsContainer);

    // Generate button container with time info
    const generateContainer = document.createElement('div');
    generateContainer.className = 'mt-3';
    generateContainer.id = 'courseSelectionGenerateContainer';
    generateContainer.style.display = 'none';
    generateContainer.innerHTML = `
        <div class="card">
            <div class="card-body">
                <div class="d-grid">
                    <button id="courseSelectionGenerateBtn" class="btn btn-primary btn-lg py-3">
                        <i class="bi bi-magic"></i> Generate Questions
                    </button>
                </div>
                <div class="mt-2 text-center">
                    <small class="text-muted" id="courseSelectionGenerationTimeNote">
                        <i class="bi bi-clock-history"></i> This may take a few minutes
                    </small>
                </div>
            </div>
        </div>
    `;
    ctrlWrap.appendChild(generateContainer);

    // Results area
    const resultsArea = document.createElement('div');
    resultsArea.className = 'mt-3';
    pdfBox.appendChild(resultsArea);

    let detectedTopics = [];
    let currentFile = null;
    let selectedTopicCount = 0;
    let currentEstimate = null;
    let preSelectedTopics = [];

    // Function to update time estimate for course selection
    async function updateCourseSelectionTimeEstimate() {
        if (selectedTopicCount === 0) {
            timeEstimateEl.style.display = 'none';
            return;
        }
        
        const questionType = document.getElementById('courseSelectionQuestionType').value;
        let numMcqs = 0;
        let numDesc = 0;
        
        if (questionType === 'mcq' || questionType === 'both') {
            const mcqValue = parseInt(document.getElementById('courseSelectionNumMcqs').value);
            numMcqs = (!isNaN(mcqValue) && mcqValue > 0) ? mcqValue : 0;
        }
        if (questionType === 'descriptive' || questionType === 'both') {
            const descValue = parseInt(document.getElementById('courseSelectionNumDesc').value);
            numDesc = (!isNaN(descValue) && descValue > 0) ? descValue : 0;
        }
        
        try {
            const response = await fetch(`${backendBase}/estimate_generation_time`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    num_topics: selectedTopicCount,
                    num_mcqs: numMcqs,
                    num_desc: numDesc,
                    question_type: questionType
                })
            });
            
            const data = await response.json();
            
            if (data.status === 'success') {
                currentEstimate = data.estimate;
                timeEstimateEl.style.display = 'block';
                
                document.getElementById('courseSelectionEstimatedTimeText').textContent = currentEstimate.estimated_time;
                
                const details = currentEstimate.details;
                let detailsText = '';
                
                if (details.total_mcqs > 0) {
                    detailsText += `${details.total_mcqs} MCQs`;
                }
                if (details.total_descriptive > 0) {
                    if (detailsText) detailsText += ' + ';
                    detailsText += `${details.total_descriptive} Descriptive questions`;
                }
                detailsText += ` across ${details.num_topics} topics`;
                
                document.getElementById('courseSelectionTimeDetails').textContent = detailsText;
                
                const noteEl = document.getElementById('courseSelectionGenerationTimeNote');
                noteEl.innerHTML = `<i class="bi bi-clock-history"></i> Estimated time: ${currentEstimate.estimated_time}`;
                
                if (currentEstimate.estimated_seconds > 300) {
                    timeEstimateEl.querySelector('.alert').className = 'alert alert-danger p-2';
                    noteEl.className = 'text-danger';
                } else if (currentEstimate.estimated_seconds > 120) {
                    timeEstimateEl.querySelector('.alert').className = 'alert alert-warning p-2';
                    noteEl.className = 'text-warning';
                } else {
                    timeEstimateEl.querySelector('.alert').className = 'alert alert-success p-2';
                    noteEl.className = 'text-success';
                }
            }
        } catch (error) {
            console.error('Failed to get time estimate for course selection:', error);
        }
    }

    function setupCourseSelectionQuestionTypeHandler() {
        const questionTypeSelect = document.getElementById('courseSelectionQuestionType');
        const mcqInputContainer = document.getElementById('courseSelectionMcqInputContainer');
        const descInputContainer = document.getElementById('courseSelectionDescInputContainer');
        const numMcqsInput = document.getElementById('courseSelectionNumMcqs');
        const numDescInput = document.getElementById('courseSelectionNumDesc');

        if (!questionTypeSelect || !mcqInputContainer || !descInputContainer) {
            console.error('Required elements not found for course selection question type handler');
            return;
        }

        function updateInputFieldsVisibility() {
            const selectedType = questionTypeSelect.value;
            
            console.log('Course Selection Question type changed to:', selectedType);
            
            switch(selectedType) {
                case 'mcq':
                    mcqInputContainer.style.display = 'block';
                    descInputContainer.style.display = 'none';
                    numDescInput.value = '';
                    numMcqsInput.value = numMcqsInput.value || '0';
                    break;
                case 'descriptive':
                    mcqInputContainer.style.display = 'none';
                    descInputContainer.style.display = 'block';
                    numMcqsInput.value = '';
                    numDescInput.value = numDescInput.value || '0';
                    break;
                case 'both':
                    mcqInputContainer.style.display = 'block';
                    descInputContainer.style.display = 'block';
                    numMcqsInput.value = numMcqsInput.value || '0';
                    numDescInput.value = numDescInput.value || '0';
                    break;
            }
            
            updateCourseSelectionTimeEstimate();
        }

        questionTypeSelect.addEventListener('change', updateInputFieldsVisibility);
        
        numMcqsInput.addEventListener('input', debounce(updateCourseSelectionTimeEstimate, 500));
        numDescInput.addEventListener('input', debounce(updateCourseSelectionTimeEstimate, 500));

        updateInputFieldsVisibility();
    }

    // PDF upload handler for course selection
     pdfInput.addEventListener('change', async (e) => {
      resultsArea.innerHTML = '';
      topicsContainer.innerHTML = '';
      tocEl.innerHTML = '';
      timeEstimateEl.style.display = 'none';
      optionsForm.style.display = 'none';
      topicsContainer.style.display = 'none';
      generateContainer.style.display = 'none';
      
      const f = e.target.files[0];
      if (!f) return;
      
      currentFile = f;
      
      // Create and show modal
      const modalElement = document.getElementById('courseSelectionPdfConfirmationModal');
      const modal = new bootstrap.Modal(modalElement);
      modal.show();
      
      // Wait for modal animation to complete
      modalElement.addEventListener('shown.bs.modal', async function onShown() {
        // Remove listener after first call
        modalElement.removeEventListener('shown.bs.modal', onShown);
        
        console.log('Course Selection Modal is now shown, loading PDF...');
        
        // Access modal elements
        const pdfInfo = document.getElementById('courseSelectionPdfInfo');
        if (pdfInfo) {
          const fileSizeMB = (f.size / 1024 / 1024).toFixed(2);
          pdfInfo.innerHTML = `
            <div class="alert alert-success">
              <div class="d-flex align-items-center">
                <i class="bi bi-file-earmark-pdf fs-4 me-3 text-danger"></i>
                <div>
                  <h6 class="mb-1">${f.name}</h6>
                  <div class="small">Size: ${fileSizeMB} MB</div>
                </div>
              </div>
            </div>
          `;
        }
        
        // Load PDF preview
        await loadCourseSelectionPDF(f);
        
        // Extract topics
        const modalInfoMessage = document.getElementById('courseSelectionModalInfoMessage');
        const modalTopicsContainer = document.getElementById('courseSelectionModalTopicsContainer');
        const confirmBtn = document.getElementById('courseSelectionConfirmContinueBtn');
        
        if (modalInfoMessage) {
          modalInfoMessage.innerHTML = `
            <div class="d-flex align-items-center">
              <div class="spinner-border spinner-border-sm me-2" role="status"></div>
              <div><i class="bi bi-info-circle"></i> Analyzing PDF to extract topics...</div>
            </div>
          `;
        }
        
        if (confirmBtn) {
          confirmBtn.disabled = true;
        }
        
        try {
          const r = await uploadAndExtractTOC(f);
          if (r.status === 'success') {
            detectedTopics = r.matches || [];
            
            if (detectedTopics.length > 0) {
              if (modalInfoMessage) modalInfoMessage.style.display = 'none';
              if (modalTopicsContainer) modalTopicsContainer.style.display = 'block';
              
              // ========== ADD THIS FUNCTION CALL ==========
              renderCourseSelectionModalTopics();
              
              if (confirmBtn) confirmBtn.disabled = false;
            } else {
              if (modalInfoMessage) {
                modalInfoMessage.className = 'alert alert-warning mt-2';
                modalInfoMessage.innerHTML = '<i class="bi bi-exclamation-triangle"></i> No topics detected in the PDF. Please try a different PDF.';
              }
              if (confirmBtn) confirmBtn.disabled = true;
            }
          } else {
            if (modalInfoMessage) {
              modalInfoMessage.className = 'alert alert-danger mt-2';
              modalInfoMessage.innerHTML = `<i class="bi bi-exclamation-triangle"></i> PDF analysis failed: ${r.error || 'unknown error'}`;
            }
            if (confirmBtn) confirmBtn.disabled = true;
          }
        } catch (err) {
          if (modalInfoMessage) {
            modalInfoMessage.className = 'alert alert-danger mt-2';
            modalInfoMessage.innerHTML = `<i class="bi bi-exclamation-triangle"></i> Error: ${err.message || err}`;
          }
          if (confirmBtn) confirmBtn.disabled = true;
        }
      });
      
      // Clean up modal after hiding
      modalElement.addEventListener('hidden.bs.modal', () => {
        // Reset PDF preview for next time
        const container = document.getElementById('courseSelectionPdfPagesContainer');
        if (container) {
          container.innerHTML = `
            <div class="text-center py-5">
              <div class="spinner-border text-primary" role="status"></div>
              <p class="mt-2">Loading PDF...</p>
            </div>
          `;
        }
        const pageCount = document.getElementById('courseSelectionPdfPageCount');
        if (pageCount) {
          pageCount.textContent = 'Loading...';
        }
      });
    });
    // Function to render topics in the course selection modal
    function renderCourseSelectionModalTopics() {
        const modalTopicsList = document.getElementById('courseSelectionModalTopicsList');
        const modalSelectedCount = document.getElementById('courseSelectionModalSelectedCount');
        
        modalTopicsList.innerHTML = '';
        
        detectedTopics.forEach((topic, idx) => {
            const topicItem = document.createElement('div');
            topicItem.className = 'mb-2 p-2 border rounded topic-item';
            topicItem.style.backgroundColor = '#fff';
            topicItem.style.transition = 'background-color 0.2s';
            
            const pageInfo = topic.page ? `<small class="text-muted"><i class="bi bi-file-earmark"></i> Page ${topic.page}</small>` : '';
            
            topicItem.innerHTML = `
                <div class="form-check">
                    <input class="form-check-input course-selection-modal-topic-checkbox" type="checkbox" 
                           value="${topic.title}" 
                           id="course_selection_modal_topic_${idx}"
                           data-page="${topic.page || ''}">
                    <label class="form-check-label w-100" for="course_selection_modal_topic_${idx}" style="cursor: pointer;">
                        <div class="d-flex justify-content-between align-items-start">
                            <div>
                                <strong>${topic.title || 'Untitled Topic'}</strong>
                                <div class="small">
                                    ${pageInfo}
                                </div>
                            </div>
                        </div>
                    </label>
                </div>
            `;
            
            modalTopicsList.appendChild(topicItem);
            
            topicItem.addEventListener('mouseenter', () => {
                topicItem.style.backgroundColor = '#f0f8ff';
            });
            topicItem.addEventListener('mouseleave', () => {
                const checkbox = topicItem.querySelector('.course-selection-modal-topic-checkbox');
                topicItem.style.backgroundColor = checkbox?.checked ? '#e7f4ff' : '#fff';
            });
        });
        
        document.getElementById('courseSelectionModalSelectAll').onclick = () => {
            modalTopicsList.querySelectorAll('.course-selection-modal-topic-checkbox').forEach(cb => {
                cb.checked = true;
                cb.closest('.topic-item').style.backgroundColor = '#e7f4ff';
            });
            updateCourseSelectionModalSelectedCount();
        };
        
        document.getElementById('courseSelectionModalDeselectAll').onclick = () => {
            modalTopicsList.querySelectorAll('.course-selection-modal-topic-checkbox').forEach(cb => {
                cb.checked = false;
                cb.closest('.topic-item').style.backgroundColor = '#fff';
            });
            updateCourseSelectionModalSelectedCount();
        };
        
        modalTopicsList.querySelectorAll('.course-selection-modal-topic-checkbox').forEach(cb => {
            cb.addEventListener('change', function() {
                this.closest('.topic-item').style.backgroundColor = this.checked ? '#e7f4ff' : '#fff';
                updateCourseSelectionModalSelectedCount();
            });
        });
        
        function updateCourseSelectionModalSelectedCount() {
            const selected = modalTopicsList.querySelectorAll('.course-selection-modal-topic-checkbox:checked').length;
            const total = detectedTopics.length;
            modalSelectedCount.textContent = `${selected} of ${total} topics selected`;
        }
        
        updateCourseSelectionModalSelectedCount();
    }

    // Handle confirmation to continue for course selection
    document.addEventListener('click', function(e) {
        if (e.target && e.target.id === 'courseSelectionConfirmContinueBtn') {
            const modalTopicsList = document.getElementById('courseSelectionModalTopicsList');
            const selectedCheckboxes = modalTopicsList ? modalTopicsList.querySelectorAll('.course-selection-modal-topic-checkbox:checked') : [];
            
            if (selectedCheckboxes.length === 0) {
                alert('Please select at least one topic to continue.');
                return;
            }
            
            preSelectedTopics = Array.from(selectedCheckboxes).map(cb => cb.value);
            
            const modal = bootstrap.Modal.getInstance(document.getElementById('courseSelectionPdfConfirmationModal'));
            modal.hide();
            
            statusEl.innerHTML = `<div class="alert alert-success">
                <i class="bi bi-check-circle"></i> PDF analyzed successfully. Found ${preSelectedTopics.length} selected topics. 
                You selected <strong>${preSelectedTopics.length}</strong> topics from the PDF.
                <div class="small mt-1">Review your selection below</div>
            </div>`;
            
            optionsForm.style.display = 'block';
            setupCourseSelectionQuestionTypeHandler();
            renderCourseSelectionTopicsSelection();
            generateContainer.style.display = 'block';
        }
    });

    // Render topics selection UI for course selection
    function renderCourseSelectionTopicsSelection() {
        topicsContainer.innerHTML = '';
        topicsContainer.style.display = 'block';
        
        const filteredTopics = detectedTopics.filter(topic => 
            preSelectedTopics.includes(topic.title)
        );
        
        if (filteredTopics.length === 0) {
            topicsContainer.innerHTML = `<div class="alert alert-warning">
                <i class="bi bi-exclamation-triangle"></i> No topics were selected. Please upload the PDF again.
            </div>`;
            return;
        }
        
        const header = document.createElement('div');
        header.className = 'mb-3';
        header.innerHTML = `
            <h6 class="mb-2"><i class="bi bi-tags"></i> Selected Topics for Question Generation:</h6>
            <div class="d-flex justify-content-between align-items-center mb-2">
                <span class="small text-muted" id="courseSelectionSelectedTopicsCount">${filteredTopics.length} topics (all pre-selected)</span>
                <div>
                    <button id="courseSelectionSelectAllTopics" class="btn btn-sm btn-outline-primary me-1">
                        <i class="bi bi-check-square"></i> Select All
                    </button>
                    <button id="courseSelectionDeselectAllTopics" class="btn btn-sm btn-outline-secondary">
                        <i class="bi bi-square"></i> Deselect All
                    </button>
                </div>
            </div>
        `;
        topicsContainer.appendChild(header);
        
        const topicsList = document.createElement('div');
        topicsList.className = 'topics-list-container';
        topicsList.style.maxHeight = '300px';
        topicsList.style.overflowY = 'auto';
        topicsList.style.border = '1px solid #dee2e6';
        topicsList.style.borderRadius = '5px';
        topicsList.style.padding = '10px';
        topicsList.style.backgroundColor = '#f8f9fa';
        
        filteredTopics.forEach((topic, idx) => {
            const topicItem = document.createElement('div');
            topicItem.className = 'mb-2 p-2 border rounded topic-item';
            topicItem.style.backgroundColor = '#e7f4ff';
            topicItem.style.transition = 'background-color 0.2s';
            
            const pageInfo = topic.page ? `<small class="text-muted"><i class="bi bi-file-earmark"></i> Page ${topic.page}</small>` : '';
            
            topicItem.innerHTML = `
                <div class="form-check">
                    <input class="form-check-input course-selection-topic-checkbox" type="checkbox" 
                           value="${topic.title}" 
                           id="course_selection_topic_${idx}"
                           data-page="${topic.page || ''}"
                           checked>
                    <label class="form-check-label w-100" for="course_selection_topic_${idx}" style="cursor: pointer;">
                        <div class="d-flex justify-content-between align-items-start">
                            <div>
                                <strong>${topic.title || 'Untitled Topic'}</strong>
                                <div class="small">
                                    ${pageInfo}
                                </div>
                            </div>
                        </div>
                    </label>
                </div>
            `;
            
            topicsList.appendChild(topicItem);
            
            topicItem.addEventListener('mouseenter', () => {
                topicItem.style.backgroundColor = '#f0f8ff';
            });
            topicItem.addEventListener('mouseleave', () => {
                const checkbox = topicItem.querySelector('.course-selection-topic-checkbox');
                topicItem.style.backgroundColor = checkbox?.checked ? '#e7f4ff' : '#fff';
            });
        });
        
        topicsContainer.appendChild(topicsList);
        
        document.getElementById('courseSelectionSelectAllTopics').addEventListener('click', () => {
            topicsList.querySelectorAll('.course-selection-topic-checkbox').forEach(cb => {
                cb.checked = true;
                cb.closest('.topic-item').style.backgroundColor = '#e7f4ff';
            });
            updateCourseSelectionSelectedTopicsCount();
            updateCourseSelectionTimeEstimate();
        });
        
        document.getElementById('courseSelectionDeselectAllTopics').addEventListener('click', () => {
            topicsList.querySelectorAll('.course-selection-topic-checkbox').forEach(cb => {
                cb.checked = false;
                cb.closest('.topic-item').style.backgroundColor = '#fff';
            });
            updateCourseSelectionSelectedTopicsCount();
            updateCourseSelectionTimeEstimate();
        });
        
        topicsList.querySelectorAll('.course-selection-topic-checkbox').forEach(cb => {
            cb.addEventListener('change', function() {
                this.closest('.topic-item').style.backgroundColor = this.checked ? '#e7f4ff' : '#fff';
                updateCourseSelectionSelectedTopicsCount();
                updateCourseSelectionTimeEstimate();
            });
        });
        
        function updateCourseSelectionSelectedTopicsCount() {
            selectedTopicCount = topicsList.querySelectorAll('.course-selection-topic-checkbox:checked').length;
            const total = filteredTopics.length;
            document.getElementById('courseSelectionSelectedTopicsCount').textContent = 
                `${selectedTopicCount} of ${total} topics selected`;
        }
        
        updateCourseSelectionSelectedTopicsCount();
        updateCourseSelectionTimeEstimate();
    }

    // Generate questions button handler for course selection
    document.getElementById('courseSelectionGenerateBtn').addEventListener('click', async () => {
    const questionType = document.getElementById('courseSelectionQuestionType').value;
    const numMcqsInput = document.getElementById('courseSelectionNumMcqs');
    const numDescInput = document.getElementById('courseSelectionNumDesc');
    let numMcqs = parseInt(numMcqsInput.value);
    let numDesc = parseInt(numDescInput.value);
    
    numMcqsInput.classList.remove('is-invalid');
    numDescInput.classList.remove('is-invalid');
    
    let isValid = true;
    
    if (questionType === 'mcq' || questionType === 'both') {
        if (isNaN(numMcqs) || numMcqs < 1 || numMcqs > 50) {
            numMcqsInput.classList.add('is-invalid');
            alert('Please enter a valid number of MCQs per topic (1-50)');
            isValid = false;
        }
    } else {
        numMcqs = 0;
    }
    
    if (questionType === 'descriptive' || questionType === 'both') {
        if (isNaN(numDesc) || numDesc < 1 || numDesc > 20) {
            numDescInput.classList.add('is-invalid');
            alert('Please enter a valid number of descriptive questions per topic (1-20)');
            isValid = false;
        }
    } else {
        numDesc = 0;
    }
    
    if (selectedTopicCount === 0) {
        alert('Please select at least one topic for question generation.');
        isValid = false;
    }
    
    if (!isValid) {
        return;
    }
    
    if (currentEstimate) {
        let confirmMessage = `You are about to generate questions for ${selectedTopicCount} topics.\n\n`;
        confirmMessage += `‚Ä¢ ${selectedTopicCount} topics\n`;
        
        if (questionType === 'mcq' || questionType === 'both') {
            confirmMessage += `‚Ä¢ ${numMcqs} MCQs per topic\n`;
        }
        if (questionType === 'descriptive' || questionType === 'both') {
            confirmMessage += `‚Ä¢ ${numDesc} descriptive questions per topic\n`;
        }
        
        confirmMessage += `\nEstimated time: ${currentEstimate.estimated_time}\n\n`;
        confirmMessage += `Do you want to continue?`;
        
        const confirmed = confirm(confirmMessage);
        
        if (!confirmed) {
            return;
        }
    }
    
    const checkedBoxes = topicsContainer.querySelectorAll('.course-selection-topic-checkbox:checked');
    const selectedTopicTitles = Array.from(checkedBoxes).map(cb => cb.value);
    const qType = questionType;
    
    // ====== THIS IS THE KEY CHANGE - SHOW MODAL ======
    const progressModal = new bootstrap.Modal(document.getElementById('generationProgressModal'));
    progressModal.show();
    
    const startTime = Date.now();
    let timeoutReached = false;
    let userCancelled = false;
    let abortController = new AbortController();
    // Set up cancel button handler
    const cancelBtn = document.getElementById('cancelGenerationBtn');
    if (cancelBtn) {
      cancelBtn.onclick = () => {
        userCancelled = true;
        abortController.abort();
        progressModal.hide();
        resultsArea.innerHTML = `
          <div class="alert alert-warning">
            <i class="bi bi-exclamation-triangle"></i> Generation cancelled by user.
          </div>
        `;
      };
    }
    
    // Update elapsed time in modal
    const timeUpdateInterval = setInterval(() => {
        if (userCancelled) {
            clearInterval(timeUpdateInterval);
            return;
        }
        
        const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsedSeconds / 60);
        const seconds = elapsedSeconds % 60;
        const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
        
        const elapsedEl = document.getElementById('elapsedTime');
        if (elapsedEl) elapsedEl.textContent = timeStr;
        
        const progressText = document.getElementById('generationProgressText');
        if (progressText) {
            progressText.textContent = `Processing ${selectedTopicCount} topics...`;
        }
        
        // Check if timeout reached
        if (currentEstimate && elapsedSeconds > currentEstimate.estimated_seconds && !timeoutReached) {
            timeoutReached = true;
            showTimeoutWarning();
        }
    }, 1000);
    // Helper function to generate hash from string
    async function generateHash(str) {
      const encoder = new TextEncoder();
      const data = encoder.encode(str);
      const hashBuffer = await crypto.subtle.digest('MD5', data).catch(() => {
        // Fallback for browsers without crypto.subtle
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return hash.toString(36);
      });
      
      if (typeof hashBuffer === 'string') return hashBuffer;
      
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }
    
    function showTimeoutWarning() {
        const warningEl = document.getElementById('timeoutWarning');
        const footerEl = document.getElementById('generationModalFooter');
        
        if (warningEl) warningEl.style.display = 'block';
        
        if (footerEl) {
            footerEl.innerHTML = `
                <button type="button" class="btn btn-secondary" id="cancelGenerationBtn">
                    <i class="bi bi-x-circle"></i> Cancel
                </button>
                <button type="button" class="btn btn-primary" id="continueGenerationBtn">
                    <i class="bi bi-check-circle"></i> Continue Waiting
                </button>
            `;
            
            document.getElementById('cancelGenerationBtn').addEventListener('click', () => {
                userCancelled = true;
                abortController.abort();
                clearInterval(timeUpdateInterval);
                progressModal.hide();
                resultsArea.innerHTML = `
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle"></i> Generation cancelled by user.
                    </div>
                `;
            });
            
            document.getElementById('continueGenerationBtn').addEventListener('click', () => {
                if (warningEl) warningEl.style.display = 'none';
                footerEl.innerHTML = '';
                timeoutReached = false;
            });
        }
    }

    try {
        const fd = new FormData();
        fd.append("file", currentFile, currentFile.name);
        fd.append("topics", JSON.stringify(selectedTopicTitles));
        fd.append("question_type", qType);
        fd.append("num_mcqs", String(numMcqs));
        fd.append("num_desc", String(numDesc));
        fd.append("is_course_selection", "true");

        // Get course data from dropdowns
        const courseData = {
            program_id: document.getElementById('courseSelectionProgramFilter').value || null,
            branch_id: document.getElementById('courseSelectionBranchFilter').value || null,
            academic_year_id: document.getElementById('courseSelectionAcademicYearFilter').value || null,
            semester_id: document.getElementById('courseSelectionSemesterFilter').value || null,
            course_id: document.getElementById('courseSelectionCourseFilter').value || null,
            component: document.getElementById('courseSelectionComponentFilter').value || null
        };
        fd.append("course_data_json", JSON.stringify(courseData));
        
        const response = await fetch(`${backendBase}/generate_pdf_mcqs`, { 
            method: "POST", 
            body: fd,
            signal: abortController.signal
        });
        
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        
        const r = await response.json();
        
        clearInterval(timeUpdateInterval);
        progressModal.hide();
        
        const endTime = Date.now();
        const actualSeconds = Math.floor((endTime - startTime) / 1000);
        const actualMinutes = Math.floor(actualSeconds / 60);
        const actualRemainingSeconds = actualSeconds % 60;
        const actualTime = actualMinutes > 0 ? 
            `${actualMinutes}m ${actualRemainingSeconds}s` : 
            `${actualSeconds}s`;
        
        if (r.status === 'success') {
            resultsArea.innerHTML = `
                <div class="alert alert-success">
                    <div class="d-flex align-items-center">
                        <i class="bi bi-check-circle-fill fs-4 me-3"></i>
                        <div>
                            <strong>Generation completed successfully!</strong>
                            <div class="small">
                                Generated questions for ${r.results_count_topics} topics in ${actualTime}
                                ${currentEstimate ? `(Estimated: ${currentEstimate.estimated_time})` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            updateDashboardFromResponse(r);

                const header = document.createElement('div'); 
                header.className='mb-3 p-3 bg-light rounded';
                header.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h6 class="mb-1"><i class="bi bi-file-text"></i> Generated Questions</h6>
                            <div class="small">
                                <span class="badge bg-primary">${Object.keys(r.results || {}).length} Topics</span>
                                <span class="badge bg-success ms-1">${r.mcqCount || 0} MCQs</span>
                                <span class="badge bg-warning ms-1">${r.descCount || 0} Descriptive</span>
                                <span class="badge bg-info ms-1">Time: ${actualTime}</span>
                            </div>
                        </div>
                        <div>
                            <span class="small text-muted">Pages: ${r.pages || 0}</span>
                        </div>
                    </div>
                    <div class="small mt-2">
                        <strong>Selected Topics:</strong> ${r.selected_topics?.slice(0, 3).join(', ') || 'N/A'}
                        ${r.selected_topics?.length > 3 ? `and ${r.selected_topics.length - 3} more...` : ''}
                    </div>
                `;
                resultsArea.appendChild(header);

                const dlRow = document.createElement('div'); 
                dlRow.className='mb-3';
                const keys = r.download_keys || {};
                
                const createDownloadBtn = (key, text, icon, color) => {
                    if (key) {
                        const a = document.createElement('a'); 
                        a.href = `${backendBase}/download/${key}`; 
                        a.className=`btn btn-${color} btn-sm me-2`;
                        a.innerHTML = `<i class="bi ${icon}"></i> ${text}`; 
                        return a;
                    }
                    return null;
                };
                
                [createDownloadBtn(keys.docx, 'Download DOCX', 'bi-file-word', 'primary'),
                 createDownloadBtn(keys.excel, 'Download Excel', 'bi-file-excel', 'success'),
                 createDownloadBtn(keys.csv, 'Download CSV', 'bi-file-earmark-text', 'secondary')]
                .filter(Boolean)
                .forEach(btn => dlRow.appendChild(btn));

               // Export to Database button for course selection
                const exportBtn = document.createElement('button');
                exportBtn.className = 'btn btn-warning btn-sm me-2';
                exportBtn.innerHTML = '<i class="bi bi-database"></i> Export to Database';
                exportBtn.addEventListener('click', async () => {
                    exportBtn.disabled = true;
                    exportBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Exporting...';
                    
                    try {
                        // Get selected course data from dropdowns
                        const courseData = {
                            program_id: document.getElementById('courseSelectionProgramFilter').value || null,
                            branch_id: document.getElementById('courseSelectionBranchFilter').value || null,
                            academic_year_id: document.getElementById('courseSelectionAcademicYearFilter').value || null,
                            semester_id: document.getElementById('courseSelectionSemesterFilter').value || null,
                            course_id: document.getElementById('courseSelectionCourseFilter').value || null,
                            component: document.getElementById('courseSelectionComponentFilter').value || null
                        };
                        
                        // Check if all required course data is filled
                        if (!courseData.program_id || !courseData.course_id) {
                            alert('Please select both Program and Course before exporting to database.');
                            exportBtn.disabled = false;
                            exportBtn.innerHTML = '<i class="bi bi-database"></i> Export to Database';
                            return;
                        }
                        
                        // Generate hash for results to track exports
                        const resultStr = JSON.stringify({ results: r.results, courseData: courseData });
                        const resultHash = await generateHash(resultStr);
                        
                        // Check if already exported
                        const checkResp = await fetch(`${backendBase}/check_export_status`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ result_hash: resultHash })
                        });
                        const checkData = await checkResp.json();
                        
                        if (checkData.is_exported) {
                            alert('‚úÖ These questions have already been exported to the course database!');
                            exportBtn.innerHTML = '<i class="bi bi-check-circle"></i> Already Exported';
                            exportBtn.classList.remove('btn-warning');
                            exportBtn.classList.add('btn-success');
                            exportBtn.disabled = true;
                            return;
                        }
                        
                        // Prepare the request data
                        const requestData = {
                            results: r.results || {},
                            pdf_name: currentFile ? currentFile.name : '',
                            course_data: courseData
                        };
                        
                        const resp = await fetch(`${backendBase}/save_questions_to_course_db`, {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'Accept': 'application/json'
                            },
                            body: JSON.stringify(requestData)
                        });
                        
                        const data = await resp.json();
                        
                        if (data.status === 'success') {
                            alert(`‚úÖ Successfully saved ${data.saved} questions to course questions database!`);
                            exportBtn.innerHTML = '<i class="bi bi-check-circle"></i> Already Exported';
                            exportBtn.classList.remove('btn-warning');
                            exportBtn.classList.add('btn-success');
                            exportBtn.disabled = true;
                        } else if (data.status === 'already_exported') {
                            // ADD THIS CONDITION - it was missing!
                            alert('‚úÖ These questions have already been exported to the course database!');
                            exportBtn.innerHTML = '<i class="bi bi-check-circle"></i> Already Exported';
                            exportBtn.classList.remove('btn-warning');
                            exportBtn.classList.add('btn-success');
                            exportBtn.disabled = true;
                        } else {
                            alert('‚ùå Export failed: ' + (data.error || 'Unknown error'));
                            exportBtn.disabled = false;
                            exportBtn.innerHTML = '<i class="bi bi-database"></i> Export to Database';
                        }
                    } catch (err) {
                        console.error('Error saving questions:', err);
                        alert('‚ö†Ô∏è Error saving questions: ' + err.message);
                        exportBtn.disabled = false;
                        exportBtn.innerHTML = '<i class="bi bi-database"></i> Export to Database';
                    }
                });
                dlRow.appendChild(exportBtn);

                resultsArea.appendChild(dlRow);

                const results = r.results || {};
                if (Object.keys(results).length > 0) {
                    const accordion = document.createElement('div');
                    accordion.className = 'accordion';
                    accordion.id = 'courseSelectionQuestionsAccordion';
                    
                    Object.entries(results).forEach(([topicTitle, data], idx) => {
                        const mcqs = data.mcqs || [];
                        const descs = data.descriptive || [];
                        const hasMCQs = mcqs.length > 0 && qType !== 'descriptive';
                        const hasDescriptive = descs.length > 0 && qType !== 'mcq';
                        
                        if (!hasMCQs && !hasDescriptive) return;
                        
                        const itemId = `course_selection_topic_${idx}`;
                        const collapseId = `course_selection_collapse_${idx}`;
                        
                        const item = document.createElement('div');
                        item.className = 'accordion-item';
                        item.innerHTML = `
                            <h2 class="accordion-header" id="${itemId}">
                                <button class="accordion-button collapsed" type="button" 
                                        data-bs-toggle="collapse" data-bs-target="#${collapseId}"
                                        aria-expanded="false" aria-controls="${collapseId}">
                                    <div class="d-flex w-100 justify-content-between align-items-center">
                                        <span>${topicTitle}</span>
                                        <div class="small">
                                            ${hasMCQs ? `<span class="badge bg-success">${mcqs.length} MCQs</span>` : ''}
                                            ${hasDescriptive ? `<span class="badge bg-warning ms-1">${descs.length} Descriptive</span>` : ''}
                                        </div>
                                    </div>
                                </button>
                            </h2>
                            <div id="${collapseId}" class="accordion-collapse collapse" 
                                 aria-labelledby="${itemId}" data-bs-parent="#courseSelectionQuestionsAccordion">
                                <div class="accordion-body">
                                    <div class="course-selection-topic-questions-content"></div>
                                </div>
                            </div>
                        `;
                        
                        accordion.appendChild(item);
                        
                        const contentDiv = item.querySelector('.course-selection-topic-questions-content');
                        
                        if (hasMCQs) {
                            const mcqSection = document.createElement('div');
                            mcqSection.className = 'mb-4';
                            mcqSection.innerHTML = `<h6 class="border-bottom pb-2">Multiple Choice Questions:</h6>`;
                            
                            mcqs.forEach((mcq, mIdx) => {
                                const mcqDiv = document.createElement('div');
                                mcqDiv.className = 'mb-3 p-3 border rounded';
                                mcqDiv.innerHTML = `
                                    <div class="fw-bold mb-2">${mIdx + 1}. ${mcq.question || ''}</div>
                                    <div class="ms-3">
                                        ${(mcq.options || []).map(opt => `<div class="mb-1">${opt}</div>`).join('')}
                                    </div>
                                    ${mcq.answer ? `<div class="text-success mt-2"><strong>Answer:</strong> ${mcq.answer}</div>` : ''}
                                    ${mcq.difficulty ? `<div class="text-muted small mt-1"><strong>Difficulty:</strong> ${mcq.difficulty}</div>` : ''}
                                `;
                                mcqSection.appendChild(mcqDiv);
                            });
                            contentDiv.appendChild(mcqSection);
                        }
                        
                        if (hasDescriptive) {
                            const descSection = document.createElement('div');
                            descSection.className = 'mt-4';
                            descSection.innerHTML = `<h6 class="border-bottom pb-2">Descriptive Questions:</h6>`;
                            
                            descs.forEach((desc, dIdx) => {
                                const descDiv = document.createElement('div');
                                descDiv.className = 'mb-3 p-3 border rounded';
                                const q = typeof desc === 'string' ? desc : (desc.question || '');
                                const a = typeof desc === 'object' ? (desc.answer || '') : '';
                                const diff = typeof desc === 'object' ? (desc.difficulty || '') : '';
                                
                                descDiv.innerHTML = `
                                    <div class="fw-bold mb-2">${dIdx + 1}. ${q}</div>
                                    ${a ? `<div class="text-success mt-2"><strong>Answer:</strong> ${a}</div>` : ''}
                                    ${diff ? `<div class="text-muted small mt-1"><strong>Difficulty:</strong> ${diff}</div>` : ''}
                                `;
                                descSection.appendChild(descDiv);
                            });
                            contentDiv.appendChild(descSection);
                        }
                    });
                    
                    resultsArea.appendChild(accordion);
                } else {
                    resultsArea.innerHTML += `<div class="alert alert-warning">
                        No questions were generated. Please try with different topics or settings.
                    </div>`;
                }
                
            } else {
                clearInterval(progressTimer);
                statusEl.innerHTML = `<div class="alert alert-danger">
                    <i class="bi bi-exclamation-triangle"></i> Generation failed: ${r.error || 'Unknown error'}
                </div>`;
            }
        } catch (err) {
            clearInterval(progressTimer);
            statusEl.innerHTML = `<div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> Error: ${err.message || err}
            </div>`;
        } finally {
            btn.disabled = false; 
            btn.innerHTML = originalText;
        }
    });

    // Real-time validation for input fields
    document.addEventListener('input', function(e) {
        if (e.target.id === 'courseSelectionNumMcqs') {
            const value = parseInt(e.target.value);
            if (isNaN(value) || value < 1 || value > 50) {
                e.target.classList.add('is-invalid');
            } else {
                e.target.classList.remove('is-invalid');
            }
        }
        
        if (e.target.id === 'courseSelectionNumDesc') {
            const value = parseInt(e.target.value);
            if (isNaN(value) || value < 1 || value > 20) {
                e.target.classList.add('is-invalid');
            } else {
                e.target.classList.remove('is-invalid');
            }
        }
    });
})();

// 2. Questions Table Functions for Course Selection Page
async function loadCourseSelectionQuestionsFromDB(searchTerm = '', questionType = '') {
    console.log('loadCourseSelectionQuestionsFromDB called with:', { searchTerm, questionType });
    
    const questionsTable = document.getElementById('courseSelectionQuestionsTable');
    const questionsCount = document.getElementById('courseSelectionQuestionsCount');
    
    questionsTable.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div><p>Loading questions...</p></div>';
    
    try {
        let url = `${backendBase}/questions`;
        const params = new URLSearchParams();
        
        if (searchTerm && searchTerm.trim() !== '') {
            params.append('search', searchTerm.trim());
        }
        
        if (questionType && questionType !== 'all') {
            params.append('qtype', questionType);
        }
        
        if (params.toString()) {
            url += '?' + params.toString();
        }
        
        console.log('Final URL:', url);
        
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const questions = await response.json();
        
        questionsCount.innerHTML = `<div class="alert alert-info">Found ${questions.length} questions</div>`;
        
        if (questions.length === 0) {
            questionsTable.innerHTML = '<div class="alert alert-warning text-center">No questions found in the database.</div>';
            return;
        }
        
        // Create table with PO and CO columns
        let tableHTML = `
        <div style="max-height: 500px; overflow-y: auto;">
          <table class="table table-striped table-hover">
            <thead class="table-light sticky-top">
              <tr>
                <th>ID</th>
                <th>Topic</th>
                <th>Type</th>
                <th>Question</th>
                <th>Options/Answer</th>
                <th>Difficulty</th>
                <th>PO</th>
                <th>CO</th>
                <th>Flagged</th>
                <th>Actions</th>
                <th>Created</th>
              </tr>
            </thead>
            <tbody>
        `;
        
        questions.forEach(q => {
            const createdDate = q.created_at ? new Date(q.created_at).toLocaleDateString() : 'N/A';
            let optionsHtml = '';
            
            if (q.type === 'MCQ') {
                optionsHtml = `
                  <div><strong>A:</strong> <span class="editable" contenteditable="true" data-field="option_a" data-id="${q.id}">${q.option_a || ''}</span></div>
                  <div><strong>B:</strong> <span class="editable" contenteditable="true" data-field="option_b" data-id="${q.id}">${q.option_b || ''}</span></div>
                  <div><strong>C:</strong> <span class="editable" contenteditable="true" data-field="option_c" data-id="${q.id}">${q.option_c || ''}</span></div>
                  <div><strong>D:</strong> <span class="editable" contenteditable="true" data-field="option_d" data-id="${q.id}">${q.option_d || ''}</span></div>
                  <div class="text-success"><strong>Answer:</strong> <span class="editable" contenteditable="true" data-field="answer" data-id="${q.id}">${q.answer || ''}</span></div>
                `;
            } else {
                optionsHtml = `
                  <div class="text-success">
                    <strong>Answer:</strong> 
                    <span class="editable" contenteditable="true" data-field="descriptive_answer" data-id="${q.id}">
                      ${q.descriptive_answer || 'Not provided'}
                    </span>
                  </div>
                `;
            }
            
            const flaggedStatus = q.flagged === true ? 
                '<span class="badge bg-success">Approved</span>' : 
                q.flagged === false ? 
                '<span class="badge bg-danger">Not Approved</span>' : 
                '<span class="badge bg-secondary">Pending</span>';
            
            tableHTML += `
              <tr class="question-row ${(q.type || '').toLowerCase()}">
                <td>${q.id}</td>
                <td>
                  <span class="editable" contenteditable="true" data-field="topic" data-id="${q.id}">
                    ${q.topic || 'N/A'}
                  </span>
                </td>
                <td><span class="badge ${q.type === 'MCQ' ? 'bg-success' : 'bg-warning'}">${q.type || 'Unknown'}</span></td>
                <td>
                  <span class="editable" contenteditable="true" data-field="question" data-id="${q.id}">
                    ${q.question || ''}
                  </span>
                </td>
                <td>${optionsHtml}</td>
                <td>
                  <select class="form-select form-select-sm difficulty-select" data-id="${q.id}">
                    <option value="">‚Äî</option>
                    ${[1,2,3,4,5].map(i => `<option value="${i}" ${q.difficulty == i ? 'selected' : ''}>${i}</option>`).join('')}
                  </select>
                </td>
                <td>
                  <select class="form-select form-select-sm po-select" data-id="${q.id}" title="Program Outcome">
                    <option value="">Select PO</option>
                    ${PO_CO_STATE.programOutcomes.map(po => 
                      `<option value="${po.id}" ${q.po_id == po.id ? 'selected' : ''} title="${po.description}">${po.description}</option>`
                    ).join('')}
                  </select>
                </td>
                <td>
                  <select class="form-select form-select-sm co-select" data-id="${q.id}" title="Course Outcome">
                    <option value="">Select CO</option>
                    ${PO_CO_STATE.courseOutcomes.map(co => 
                      `<option value="${co.id}" ${q.co_id == co.id ? 'selected' : ''} title="${co.description}">${co.description}</option>`
                    ).join('')}
                  </select>
                </td>
                <td>${flaggedStatus}</td>
                <td>
                  <div class="btn-group btn-group-sm">
                    <button class="btn btn-success approve-btn" data-id="${q.id}" title="Approve Question" ${q.flagged === true ? 'disabled' : ''}>
                      ‚úì
                    </button>
                    <button class="btn btn-danger reject-btn" data-id="${q.id}" title="Reject Question" ${q.flagged === false ? 'disabled' : ''}>
                      ‚úó
                    </button>
                  </div>
                </td>
                <td>${createdDate}</td>
              </tr>
            `;
        });
        
        tableHTML += '</tbody></table></div>';
        questionsTable.innerHTML = tableHTML;
        
        initializeCourseSelectionQuestionTableEventListeners();
        
    } catch (error) {
        console.error('Error loading questions:', error);
        questionsTable.innerHTML = '<div class="alert alert-danger">Error loading questions from database: ' + error.message + '</div>';
    }
}

// 3. Initialize question table event listeners for course selection
function initializeCourseSelectionQuestionTableEventListeners() {
    // Existing editable field listeners
    document.querySelectorAll('#courseSelectionQuestionsTable .editable').forEach(element => {
        element.addEventListener('blur', function() {
            const questionId = this.getAttribute('data-id');
            const field = this.getAttribute('data-field');
            const value = this.innerText.trim();
            
            if (questionId && field) {
                updateQuestionField(questionId, field, value);
            }
        });
        
        element.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.blur();
            }
        });
    });
    
    // Difficulty select listeners
    document.querySelectorAll('#courseSelectionQuestionsTable .difficulty-select').forEach(select => {
        select.addEventListener('change', function() {
            const questionId = this.getAttribute('data-id');
            const value = this.value;
            
            if (questionId) {
                updateQuestionField(questionId, 'difficulty', value);
            }
        });
    });
    
    // PO select listeners
    document.querySelectorAll('#courseSelectionQuestionsTable .po-select').forEach(select => {
        select.addEventListener('change', function() {
            const questionId = this.getAttribute('data-id');
            const value = this.value;
            
            if (questionId) {
                updateQuestionField(questionId, 'po_id', value);
            }
        });
    });
    
    // CO select listeners
    document.querySelectorAll('#courseSelectionQuestionsTable .co-select').forEach(select => {
        select.addEventListener('change', function() {
            const questionId = this.getAttribute('data-id');
            const value = this.value;
            
            if (questionId) {
                updateQuestionField(questionId, 'co_id', value);
            }
        });
    });
    
    // Approve button listeners
    document.querySelectorAll('#courseSelectionQuestionsTable .approve-btn').forEach(button => {
            button.addEventListener('click', function() {
            const questionId = this.getAttribute('data-id');
            if (questionId) {
                // Show confirmation dialog
                if (confirm('Are you sure you want to REJECT this question?')) {
                    updateQuestionFlag(questionId, false);
                }
            }
        });
    });
    
    // Reject button listeners
    document.querySelectorAll('#courseSelectionQuestionsTable .reject-btn').forEach(button => {
            button.addEventListener('click', function() {
            const questionId = this.getAttribute('data-id');
            if (questionId) {
                // Show confirmation dialog
                if (confirm('Are you sure you want to REJECT this question?')) {
                    updateQuestionFlag(questionId, false);
                }
            }
        });
    });
}

// 4. Function to load faculty filters for course selection page
async function loadCourseSelectionFacultyFilters() {
    if (!CURRENT_FACULTY) {
        console.error('No faculty logged in');
        return Promise.resolve();
    }
    
    try {
        console.log('Loading filters for faculty in course selection:', CURRENT_FACULTY.id);
        const response = await fetch(`${backendBase}/get_faculty_filters/${CURRENT_FACULTY.id}`);
        const data = await response.json();
        
        console.log('Course Selection Faculty filters response:', data);
        
        if (data.error) {
            console.error('Error loading filters:', data.error);
            return Promise.resolve();
        }
        
        // Clear and populate Program dropdown
        const programFilter = document.getElementById('courseSelectionProgramFilter');
        if (programFilter) {
            programFilter.innerHTML = '<option value="">Select Program</option>';
            
            if (data.programs && data.programs.length > 0) {
                console.log('Populating programs:', data.programs);
                data.programs.forEach(program => {
                    const option = document.createElement('option');
                    option.value = program.id;
                    option.textContent = program.name;
                    programFilter.appendChild(option);
                });
                // ADD PROGRAM CHANGE LISTENER HERE
                console.log('‚òÖ Found courseSelectionProgramFilter element, attaching listener');
                
                // Remove any existing listeners
                programFilter.removeEventListener('change', handleCourseSelectionProgramChange);
                // Add new listener
                programFilter.addEventListener('change', handleCourseSelectionProgramChange);
                
                console.log('‚òÖ Course Selection Program dropdown listener attached successfully');
            } else {
                console.warn('No programs found for this faculty');
            }
        }
        
        // Reset other dropdowns
        ['courseSelectionBranchFilter', 'courseSelectionAcademicYearFilter', 
         'courseSelectionSemesterFilter', 'courseSelectionCourseFilter'].forEach(id => {
            const select = document.getElementById(id);
            if (select) {
                select.innerHTML = `<option value="">Select ${id.replace('courseSelection', '').replace('Filter', '')}</option>`;
                select.disabled = true;
            }
        });
        
        // Reset Component dropdown
        const componentFilter = document.getElementById('courseSelectionComponentFilter');
        if (componentFilter) {
            componentFilter.innerHTML = '<option value="">Select Component</option>';
            componentFilter.disabled = true;
        }
        
        console.log('Course Selection Faculty filters loaded successfully');
        return Promise.resolve();
        
    } catch (error) {
        console.error('Error loading course selection faculty filters:', error);
        return Promise.resolve();
    }
}

// 5. Function to apply filters for course selection page
function applyCourseSelectionFilters() {
    const program = document.getElementById('courseSelectionProgramFilter').value;
    const branch = document.getElementById('courseSelectionBranchFilter').value;
    const year = document.getElementById('courseSelectionAcademicYearFilter').value;
    const semester = document.getElementById('courseSelectionSemesterFilter').value;
    const course = document.getElementById('courseSelectionCourseFilter').value;
    const component = document.getElementById('courseSelectionComponentFilter').value;
    
    console.log('Course Selection Filter values selected:', { 
        program, branch, year, semester, course, component 
    });
    
    // Show a notification about selected filters
    if (program || branch || year || semester || course || component) {
        const filterInfo = [];
        if (program) filterInfo.push(`Program: ${program}`);
        if (branch) filterInfo.push(`Branch: ${branch}`);
        if (year) filterInfo.push(`Year: ${year}`);
        if (semester) filterInfo.push(`Semester: ${semester}`);
        if (course) filterInfo.push(`Course: ${course}`);
        if (component) filterInfo.push(`Component: ${component}`);
        
        showNotification(`Course Selection Filters selected: ${filterInfo.join(', ')}`, 'info');
    }
    
    // Load questions
    const searchInput = document.getElementById('courseSelectionSearchInput');
    const questionTypeSelect = document.getElementById('courseSelectionQuestionTypeSelect');
    
    loadCourseSelectionQuestionsFromDB(
        searchInput ? searchInput.value : '',
        questionTypeSelect ? questionTypeSelect.value : 'all'
    );
}

// 6. Initialize search functionality for course selection page
function initializeCourseSelectionSearchFunctionality() {
    const searchInput = document.getElementById('courseSelectionSearchInput');
    const questionTypeSelect = document.getElementById('courseSelectionQuestionTypeSelect');
    const searchBtn = document.getElementById('courseSelectionSearchBtn');
    
    // Handle search button click
    if (searchBtn) {
        searchBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const searchTerm = searchInput ? searchInput.value : '';
            const questionType = questionTypeSelect ? questionTypeSelect.value : 'all';
            console.log('Course Selection Searching for:', searchTerm, 'Type:', questionType);
            loadCourseSelectionQuestionsFromDB(searchTerm, questionType);
        });
    }
    
    // Also trigger search when type changes
    if (questionTypeSelect) {
        questionTypeSelect.addEventListener('change', function() {
            const searchTerm = searchInput ? searchInput.value : '';
            const questionType = this.value;
            console.log('Course Selection Type changed - Searching for:', searchTerm, 'Type:', questionType);
            loadCourseSelectionQuestionsFromDB(searchTerm, questionType);
        });
    }
    
    // Live search with debounce
    if (searchInput) {
        const doSearch = () => {
            const q = searchInput.value ? searchInput.value.trim() : '';
            const type = (questionTypeSelect && questionTypeSelect.value) ? questionTypeSelect.value : 'all';
            loadCourseSelectionQuestionsFromDB(q, type);
        };
        
        searchInput.addEventListener('input', debounce(doSearch, 300));
    }
}

// 7. Add dropdown change handlers for course selection page
(function initializeCourseSelectionDropdowns() {
    const programFilter = document.getElementById('courseSelectionProgramFilter');
    
    if (programFilter) {
        programFilter.addEventListener('change', function() {
            const selectedProgram = this.value;
            console.log('Course Selection Program selected:', selectedProgram);
            
            if (selectedProgram) {
                // You would need to implement loadCourseSelectionProgramDetails similar to original
                // For now, just enable other dropdowns
                ['courseSelectionBranchFilter', 'courseSelectionAcademicYearFilter', 
                 'courseSelectionSemesterFilter', 'courseSelectionCourseFilter'].forEach(id => {
                    const select = document.getElementById(id);
                    if (select) {
                        select.disabled = false;
                    }
                });
            }
        });
    }
})();

// 8. Handler for program change in course selection page (COMPLETE VERSION)
function handleCourseSelectionProgramChange() {
    const selectedProgram = this.value;
    console.log('‚òÖ‚òÖ‚òÖ COURSE SELECTION PROGRAM CHANGED TO:', selectedProgram);
    
    if (selectedProgram) {
        console.log('‚òÖ‚òÖ‚òÖ Calling loadCourseSelectionProgramDetails for:', selectedProgram);
        loadCourseSelectionProgramDetails(selectedProgram);
    } else {
        console.log('‚òÖ‚òÖ‚òÖ No program selected, resetting dropdowns');
        // Reset other dropdowns if no program selected
        ['courseSelectionBranchFilter', 'courseSelectionAcademicYearFilter', 
         'courseSelectionSemesterFilter', 'courseSelectionCourseFilter', 
         'courseSelectionComponentFilter'].forEach(id => {
            const select = document.getElementById(id);
            if (select) {
                select.innerHTML = `<option value="">Select ${id.replace('courseSelection', '').replace('Filter', '')}</option>`;
                select.disabled = true;
            }
        });
    }
}

// 9. Function to load program details for course selection (COMPLETE VERSION)
async function loadCourseSelectionProgramDetails(programId) {
    console.log('‚ñ∂‚ñ∂‚ñ∂ loadCourseSelectionProgramDetails called with programId:', programId);
    
    if (!CURRENT_FACULTY) {
        console.error('‚ùå No CURRENT_FACULTY found for course selection');
        return;
    }
    
    if (!programId) {
        console.error('‚ùå No programId provided for course selection');
        return;
    }
    
    try {
        const url = `${backendBase}/get_program_details/${CURRENT_FACULTY.id}/${programId}`;
        console.log('‚ñ∂ Fetching from URL:', url);
        
        const response = await fetch(url);
        console.log('‚ñ∂ Response status:', response.status);
        
        if (!response.ok) {
            console.error('‚ùå Response not OK:', response.status);
            return;
        }
        
        const data = await response.json();
        console.log('‚ñ∂‚ñ∂‚ñ∂ RECEIVED DATA for course selection:', JSON.stringify(data, null, 2));
        
        if (data.error) {
            console.error('‚ùå API returned error:', data.error);
            alert('Error loading program details: ' + data.error);
            return;
        }
        
        // Load program outcomes for this program
        await loadCourseSelectionProgramOutcomes(programId);
        
        // Populate Branch dropdown
        console.log('‚ñ∂ Populating Branch dropdown...');
        const branchFilter = document.getElementById('courseSelectionBranchFilter');
        if (branchFilter) {
            branchFilter.innerHTML = '<option value="">All Branches</option>';
            branchFilter.disabled = false;
            
            if (data.branches && data.branches.length > 0) {
                data.branches.forEach(branch => {
                    const option = document.createElement('option');
                    option.value = branch.id;
                    option.textContent = branch.name;
                    branchFilter.appendChild(option);
                });
                console.log('‚úì‚úì‚úì Populated', data.branches.length, 'branches');
            }
        }
        
        // Populate Academic Year dropdown
        console.log('‚ñ∂ Populating Academic Year dropdown...');
        const academicYearFilter = document.getElementById('courseSelectionAcademicYearFilter');
        if (academicYearFilter) {
            academicYearFilter.innerHTML = '<option value="">All Years</option>';
            academicYearFilter.disabled = false;
            
            if (data.academic_years && data.academic_years.length > 0) {
                data.academic_years.forEach(year => {
                    const option = document.createElement('option');
                    option.value = year.id;
                    option.textContent = year.name;
                    academicYearFilter.appendChild(option);
                });
                console.log('‚úì‚úì‚úì Populated', data.academic_years.length, 'academic years');
            }
        }
        
        // Populate Semester dropdown
        console.log('‚ñ∂ Populating Semester dropdown...');
        const semesterFilter = document.getElementById('courseSelectionSemesterFilter');
        if (semesterFilter) {
            semesterFilter.innerHTML = '<option value="">All Semesters</option>';
            semesterFilter.disabled = false;
            
            if (data.semesters && data.semesters.length > 0) {
                data.semesters.forEach(semester => {
                    const option = document.createElement('option');
                    option.value = semester.id;
                    option.textContent = semester.name;
                    option.setAttribute('data-name', semester.name);
                    semesterFilter.appendChild(option);
                });
                console.log('‚úì‚úì‚úì Populated', data.semesters.length, 'semesters');
            }
        }
        
        // Populate Course dropdown
        console.log('‚ñ∂ Populating Course dropdown...');
        const courseFilter = document.getElementById('courseSelectionCourseFilter');
        if (courseFilter) {
            courseFilter.innerHTML = '<option value="">All Courses</option>';
            courseFilter.disabled = false;
            
            if (data.courses && data.courses.length > 0) {
                data.courses.forEach(course => {
                    const option = document.createElement('option');
                    option.value = course.id;
                    option.textContent = course.name;
                    option.setAttribute('data-name', course.name);
                    courseFilter.appendChild(option);
                });
                console.log('‚úì‚úì‚úì Populated', data.courses.length, 'courses');
            }
            
            // ADD EVENT LISTENER FOR COURSE CHANGE TO LOAD COMPONENTS
            courseFilter.removeEventListener('change', handleCourseSelectionCourseChange);
            courseFilter.addEventListener('change', handleCourseSelectionCourseChange);
            console.log('‚úì Course dropdown listener attached for course selection');
        }
        
        // Reset Component dropdown
        const componentFilter = document.getElementById('courseSelectionComponentFilter');
        if (componentFilter) {
            componentFilter.innerHTML = '<option value="">Select Component</option>';
            componentFilter.disabled = true;
        }
        
        console.log('‚úì‚úì‚úì ALL COURSE SELECTION DROPDOWNS POPULATED SUCCESSFULLY ‚úì‚úì‚úì');
        
    } catch (error) {
        console.error('‚ùå‚ùå‚ùå EXCEPTION in loadCourseSelectionProgramDetails:', error);
        alert('Error loading program details: ' + error.message);
    }
}

// 10. Handler for course change in course selection page
function handleCourseSelectionCourseChange() {
    const selectedCourse = this.value;
    console.log('‚òÖ‚òÖ‚òÖ COURSE SELECTION COURSE CHANGED TO:', selectedCourse);
    
    if (selectedCourse) {
        loadCourseSelectionComponents(selectedCourse);
        loadCourseSelectionCourseOutcomes(selectedCourse);
    } else {
        const componentFilter = document.getElementById('courseSelectionComponentFilter');
        if (componentFilter) {
            componentFilter.innerHTML = '<option value="">Select Component</option>';
            componentFilter.disabled = true;
        }
    }
}

// 11. Function to load components for course selection page
async function loadCourseSelectionComponents(courseId) {
    console.log('‚ñ∂‚ñ∂‚ñ∂ loadCourseSelectionComponents called with courseId:', courseId);
    
    if (!courseId) {
        console.error('‚ùå No courseId provided for course selection');
        return;
    }
    
    try {
        const url = `${backendBase}/get_components/${courseId}`;
        console.log('‚ñ∂ Fetching components from URL:', url);
        
        const response = await fetch(url);
        console.log('‚ñ∂ Response status:', response.status);
        
        if (!response.ok) {
            console.error('‚ùå Response not OK:', response.status);
            return;
        }
        
        const data = await response.json();
        console.log('‚ñ∂‚ñ∂‚ñ∂ RECEIVED COMPONENT DATA for course selection:', JSON.stringify(data, null, 2));
        
        if (data.error) {
            console.error('‚ùå API returned error:', data.error);
            return;
        }
        
        // Populate Component dropdown
        console.log('‚ñ∂ Populating Component dropdown...');
        const componentFilter = document.getElementById('courseSelectionComponentFilter');
        if (componentFilter) {
            componentFilter.innerHTML = '<option value="">All Components</option>';
            componentFilter.disabled = false;
            
            if (data.components && data.components.length > 0) {
                data.components.forEach(component => {
                    const option = document.createElement('option');
                    option.value = component;
                    option.textContent = component;
                    componentFilter.appendChild(option);
                });
                console.log('‚úì‚úì‚úì Populated', data.components.length, 'components');
            } else {
                console.warn('‚ö† No components found for this course in course selection');
                componentFilter.innerHTML = '<option value="">No Components</option>';
            }
        } else {
            console.error('‚ùå courseSelectionComponentFilter element NOT FOUND!');
        }
        
        console.log('‚úì‚úì‚úì COURSE SELECTION COMPONENT DROPDOWN POPULATED SUCCESSFULLY ‚úì‚úì‚úì');
        
    } catch (error) {
        console.error('‚ùå‚ùå‚ùå EXCEPTION in loadCourseSelectionComponents:', error);
    }
}

// 12. Function to load program outcomes for course selection
async function loadCourseSelectionProgramOutcomes(programId) {
    if (!programId) {
        console.warn('No programId provided to loadCourseSelectionProgramOutcomes');
        return;
    }
    
    try {
        console.log('üîµ Loading Program Outcomes for course selection programId:', programId);
        const response = await fetch(`${backendBase}/get_program_outcomes/${programId}`);
        const data = await response.json();
        
        console.log('üîµ Course Selection Program Outcomes response:', data);
        
        if (data.error) {
            console.error('‚ùå Error loading program outcomes for course selection:', data.error);
            return;
        }
        
        // Store in global state for use in table
        // Note: We're using the same PO_CO_STATE global variable
        // You might want to create a separate state for course selection if needed
        PO_CO_STATE.programOutcomes = data.program_outcomes || [];
        PO_CO_STATE.selectedProgramId = programId;
        
        console.log('‚úÖ Course Selection Program Outcomes loaded:', PO_CO_STATE.programOutcomes.length, 'outcomes');
        
    } catch (error) {
        console.error('‚ùå Exception loading course selection program outcomes:', error);
    }
}

// 13. Function to load course outcomes for course selection
async function loadCourseSelectionCourseOutcomes(courseId) {
    if (!courseId) {
        console.warn('No courseId provided to loadCourseSelectionCourseOutcomes');
        return;
    }
    
    try {
        console.log('üü¢ Loading Course Outcomes for course selection courseId:', courseId);
        const response = await fetch(`${backendBase}/get_course_outcomes/${courseId}`);
        const data = await response.json();
        
        console.log('üü¢ Course Selection Course Outcomes response:', data);
        
        if (data.error) {
            console.error('‚ùå Error loading course outcomes for course selection:', data.error);
            return;
        }
        
        // Store in global state for use in table
        PO_CO_STATE.courseOutcomes = data.course_outcomes || [];
        PO_CO_STATE.selectedCourseId = courseId;
        
        console.log('‚úÖ Course Selection Course Outcomes loaded:', PO_CO_STATE.courseOutcomes.length, 'outcomes');
        
    } catch (error) {
        console.error('‚ùå Exception loading course selection course outcomes:', error);
    }
}
// ========== COURSE QUESTIONS PAGE FUNCTIONS ==========

// Global state for course questions
const COURSE_QUESTIONS_STATE = {
    programOutcomes: [],
    courseOutcomes: [],
    selectedProgramId: null,
    selectedCourseId: null
};

// Function to load faculty filters for course questions page
async function loadCourseQFacultyFilters() {
    if (!CURRENT_FACULTY) {
        console.error('No faculty logged in');
        return Promise.resolve();
    }
    
    try {
        console.log('Loading filters for faculty in course questions:', CURRENT_FACULTY.id);
        const response = await fetch(`${backendBase}/get_faculty_filters/${CURRENT_FACULTY.id}`);
        const data = await response.json();
        
        if (data.error) {
            console.error('Error loading filters:', data.error);
            return Promise.resolve();
        }
        
        // Clear and populate Program dropdown
        const programFilter = document.getElementById('courseQProgramFilter');
        if (programFilter) {
            programFilter.innerHTML = '<option value="">Select Program</option>';
            
            if (data.programs && data.programs.length > 0) {
                data.programs.forEach(program => {
                    const option = document.createElement('option');
                    option.value = program.id;
                    option.textContent = program.name;
                    programFilter.appendChild(option);
                });
                
                // Add program change listener
                programFilter.removeEventListener('change', handleCourseQProgramChange);
                programFilter.addEventListener('change', handleCourseQProgramChange);
            }
        }
        
        // Reset other dropdowns
        ['courseQBranchFilter', 'courseQAcademicYearFilter', 
         'courseQSemesterFilter', 'courseQCourseFilter'].forEach(id => {
            const select = document.getElementById(id);
            if (select) {
                select.innerHTML = `<option value="">Select ${id.replace('courseQ', '').replace('Filter', '')}</option>`;
                select.disabled = true;
            }
        });
        
        console.log('Course Questions Faculty filters loaded successfully');
        return Promise.resolve();
        
    } catch (error) {
        console.error('Error loading course questions faculty filters:', error);
        return Promise.resolve();
    }
}

// Handler for program change in course questions page
function handleCourseQProgramChange() {
    const selectedProgram = this.value;
    console.log('Course Questions Program changed to:', selectedProgram);
    
    if (selectedProgram) {
        loadCourseQProgramDetails(selectedProgram);
        loadCourseQProgramOutcomes(selectedProgram);
    } else {
        // Reset other dropdowns if no program selected
        ['courseQBranchFilter', 'courseQAcademicYearFilter', 
         'courseQSemesterFilter', 'courseQCourseFilter'].forEach(id => {
            const select = document.getElementById(id);
            if (select) {
                select.innerHTML = `<option value="">Select ${id.replace('courseQ', '').replace('Filter', '')}</option>`;
                select.disabled = true;
            }
        });
    }
}

// Function to load program details for course questions
async function loadCourseQProgramDetails(programId) {
    if (!CURRENT_FACULTY || !programId) return;
    
    try {
        const url = `${backendBase}/get_program_details/${CURRENT_FACULTY.id}/${programId}`;
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.error) {
            console.error('Error loading program details:', data.error);
            return;
        }
        
        // Populate Branch dropdown
        const branchFilter = document.getElementById('courseQBranchFilter');
        if (branchFilter && data.branches) {
            branchFilter.innerHTML = '<option value="">All Branches</option>';
            branchFilter.disabled = false;
            data.branches.forEach(branch => {
                const option = document.createElement('option');
                option.value = branch.id;
                option.textContent = branch.name;
                branchFilter.appendChild(option);
            });
        }
        
        // Populate Academic Year dropdown
        const academicYearFilter = document.getElementById('courseQAcademicYearFilter');
        if (academicYearFilter && data.academic_years) {
            academicYearFilter.innerHTML = '<option value="">All Years</option>';
            academicYearFilter.disabled = false;
            data.academic_years.forEach(year => {
                const option = document.createElement('option');
                option.value = year.id;
                option.textContent = year.name;
                academicYearFilter.appendChild(option);
            });
        }
        
        // Populate Semester dropdown
        const semesterFilter = document.getElementById('courseQSemesterFilter');
        if (semesterFilter && data.semesters) {
            semesterFilter.innerHTML = '<option value="">All Semesters</option>';
            semesterFilter.disabled = false;
            data.semesters.forEach(semester => {
                const option = document.createElement('option');
                option.value = semester.id;
                option.textContent = semester.name;
                semesterFilter.appendChild(option);
            });
        }
        
        // Populate Course dropdown
        const courseFilter = document.getElementById('courseQCourseFilter');
        if (courseFilter && data.courses) {
            courseFilter.innerHTML = '<option value="">All Courses</option>';
            courseFilter.disabled = false;
            data.courses.forEach(course => {
                const option = document.createElement('option');
                option.value = course.id;
                option.textContent = course.name;
                courseFilter.appendChild(option);
            });
            
            // Add course change listener
            courseFilter.removeEventListener('change', handleCourseQCourseChange);
            courseFilter.addEventListener('change', handleCourseQCourseChange);
        }
        
    } catch (error) {
        console.error('Error loading course questions program details:', error);
    }
}

// Handler for course change in course questions page
function handleCourseQCourseChange() {
    const selectedCourse = this.value;
    console.log('Course Questions Course changed to:', selectedCourse);
    
    if (selectedCourse) {
        loadCourseQCourseOutcomes(selectedCourse);
    }
}

// Function to load program outcomes for course questions
async function loadCourseQProgramOutcomes(programId) {
    try {
        const response = await fetch(`${backendBase}/get_program_outcomes/${programId}`);
        const data = await response.json();
        
        if (!data.error) {
            COURSE_QUESTIONS_STATE.programOutcomes = data.program_outcomes || [];
            COURSE_QUESTIONS_STATE.selectedProgramId = programId;
        }
    } catch (error) {
        console.error('Error loading program outcomes for course questions:', error);
    }
}

// Function to load course outcomes for course questions
async function loadCourseQCourseOutcomes(courseId) {
    try {
        const response = await fetch(`${backendBase}/get_course_outcomes/${courseId}`);
        const data = await response.json();
        
        if (!data.error) {
            COURSE_QUESTIONS_STATE.courseOutcomes = data.course_outcomes || [];
            COURSE_QUESTIONS_STATE.selectedCourseId = courseId;
        }
    } catch (error) {
        console.error('Error loading course outcomes for course questions:', error);
    }
}

// Function to apply filters for course questions page
function applyCourseQFilters() {
    const program = document.getElementById('courseQProgramFilter').value;
    const branch = document.getElementById('courseQBranchFilter').value;
    const year = document.getElementById('courseQAcademicYearFilter').value;
    const semester = document.getElementById('courseQSemesterFilter').value;
    const course = document.getElementById('courseQCourseFilter').value;
    
    console.log('Course Questions Filter values selected:', { 
        program, branch, year, semester, course 
    });
    
    // Load questions
    const searchInput = document.getElementById('courseQSearchInput');
    const questionTypeSelect = document.getElementById('courseQQuestionTypeSelect');
    const difficultyFilter = document.getElementById('courseQDifficultyFilter');
    
    loadCourseQuestionsFromDB(
        searchInput ? searchInput.value : '',
        questionTypeSelect ? questionTypeSelect.value : 'all',
        difficultyFilter ? difficultyFilter.value : 'all',
        program,
        course
    );
}

// Function to load course questions from database
async function loadCourseQuestionsFromDB(
    searchTerm = '', 
    questionType = '', 
    difficulty = '',
    programId = '',
    courseId = ''
) {
    console.log('loadCourseQuestionsFromDB called with:', { 
        searchTerm, questionType, difficulty, programId, courseId 
    });
    
    const questionsTable = document.getElementById('courseQuestionsTable');
    const questionsCount = document.getElementById('courseQuestionsCount');
    
    questionsTable.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div><p>Loading course questions...</p></div>';
    
    try {
        let url = `${backendBase}/course_questions`;
        const params = new URLSearchParams();
        
        if (searchTerm && searchTerm.trim() !== '') {
            params.append('search', searchTerm.trim());
        }
        
        if (questionType && questionType !== 'all') {
            params.append('qtype', questionType);
        }
        
        if (difficulty && difficulty !== 'all') {
            params.append('difficulty', difficulty);
        }
        
        if (programId) {
            params.append('program_id', programId);
        }
        
        if (courseId) {
            params.append('course_id', courseId);
        }
        
        // PDF filter
        const pdfFilter = document.getElementById('courseQPdfFilter');
        if (pdfFilter && pdfFilter.value) {
            params.append('pdf', pdfFilter.value);
        }
        
        if (params.toString()) {
            url += '?' + params.toString();
        }
        
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const questions = await response.json();
        
        questionsCount.innerHTML = `<div class="alert alert-info">Found ${questions.length} course questions</div>`;
        
        if (questions.length === 0) {
            questionsTable.innerHTML = '<div class="alert alert-warning text-center">No course questions found.</div>';
            return;
        }
        
        // Create table
        let tableHTML = `
        <div style="max-height: 500px; overflow-y: auto;">
          <table class="table table-striped table-hover">
            <thead class="table-light sticky-top">
              <tr>
                <th>ID</th>
                <th>Topic</th>
                <th>Type</th>
                <th>Question</th>
                <th>Options/Answer</th>
                <th>Difficulty</th>
                <th>PO</th>
                <th>CO</th>
                <th>Program</th>
                <th>Course</th>
                <th>Component</th>
                <th>PDF</th>
                <th>Flagged</th>
                <th>Actions</th>
                <th>Created</th>
              </tr>
            </thead>
            <tbody>
        `;
        
        questions.forEach(q => {
            const createdDate = q.created_at ? new Date(q.created_at).toLocaleDateString() : 'N/A';
            let optionsHtml = '';
            
            if (q.type === 'MCQ') {
                optionsHtml = `
                  <div><strong>A:</strong> <span class="editable-course" contenteditable="true" data-field="option_a" data-id="${q.id}">${q.option_a || ''}</span></div>
                  <div><strong>B:</strong> <span class="editable-course" contenteditable="true" data-field="option_b" data-id="${q.id}">${q.option_b || ''}</span></div>
                  <div><strong>C:</strong> <span class="editable-course" contenteditable="true" data-field="option_c" data-id="${q.id}">${q.option_c || ''}</span></div>
                  <div><strong>D:</strong> <span class="editable-course" contenteditable="true" data-field="option_d" data-id="${q.id}">${q.option_d || ''}</span></div>
                  <div class="text-success"><strong>Answer:</strong> <span class="editable-course" contenteditable="true" data-field="answer" data-id="${q.id}">${q.answer || ''}</span></div>
                `;
            } else {
                optionsHtml = `
                  <div class="text-success">
                    <strong>Answer:</strong> 
                    <span class="editable-course" contenteditable="true" data-field="descriptive_answer" data-id="${q.id}">
                      ${q.descriptive_answer || 'Not provided'}
                    </span>
                  </div>
                `;
            }
            
            const flaggedStatus = q.flagged === true ? 
                '<span class="badge bg-success">Approved</span>' : 
                q.flagged === false ? 
                '<span class="badge bg-danger">Not Approved</span>' : 
                '<span class="badge bg-secondary">Pending</span>';
            
            tableHTML += `
              <tr class="question-row ${(q.type || '').toLowerCase()}">
                <td>${q.id}</td>
                <td>
                  <span class="editable-course" contenteditable="true" data-field="topic" data-id="${q.id}">
                    ${q.topic || 'N/A'}
                  </span>
                </td>
                <td><span class="badge ${q.type === 'MCQ' ? 'bg-success' : 'bg-warning'}">${q.type || 'Unknown'}</span></td>
                <td>
                  <span class="editable-course" contenteditable="true" data-field="question" data-id="${q.id}">
                    ${q.question || ''}
                  </span>
                </td>
                <td>${optionsHtml}</td>
                <td>
                  <select class="form-select form-select-sm course-difficulty-select" data-id="${q.id}">
                    <option value="">‚Äî</option>
                    ${[1,2,3,4,5].map(i => `<option value="${i}" ${q.difficulty == i ? 'selected' : ''}>${i}</option>`).join('')}
                  </select>
                </td>
                <td>
                  <select class="form-select form-select-sm course-po-select" data-id="${q.id}" title="Program Outcome">
                    <option value="">Select PO</option>
                    ${COURSE_QUESTIONS_STATE.programOutcomes.map(po => 
                      `<option value="${po.id}" ${q.po_id == po.id ? 'selected' : ''} title="${po.description}">${po.description}</option>`
                    ).join('')}
                  </select>
                </td>
                <td>
                  <select class="form-select form-select-sm course-co-select" data-id="${q.id}" title="Course Outcome">
                    <option value="">Select CO</option>
                    ${COURSE_QUESTIONS_STATE.courseOutcomes.map(co => 
                      `<option value="${co.id}" ${q.co_id == co.id ? 'selected' : ''} title="${co.description}">${co.description}</option>`
                    ).join('')}
                  </select>
                </td>
                <td>${q.program_id || ''}</td>
                <td>${q.course_id || ''}</td>
                <td>${q.component || ''}</td>
                <td>${q.pdf_name || ''}</td>
                <td>${flaggedStatus}</td>
                <td>
                  <div class="btn-group btn-group-sm">
                    <button class="btn btn-success course-approve-btn" data-id="${q.id}" title="Approve Question" ${q.flagged === true ? 'disabled' : ''}>
                      ‚úì
                    </button>
                    <button class="btn btn-danger course-reject-btn" data-id="${q.id}" title="Reject Question" ${q.flagged === false ? 'disabled' : ''}>
                      ‚úó
                    </button>
                  </div>
                </td>
                <td>${createdDate}</td>
              </tr>
            `;
        });
        
        tableHTML += '</tbody></table></div>';
        questionsTable.innerHTML = tableHTML;
        
        initializeCourseQuestionsTableEventListeners();
        
    } catch (error) {
        console.error('Error loading course questions:', error);
        questionsTable.innerHTML = '<div class="alert alert-danger">Error loading course questions: ' + error.message + '</div>';
    }
}

// Initialize event listeners for course questions table
function initializeCourseQuestionsTableEventListeners() {
    // Editable field listeners
    document.querySelectorAll('#courseQuestionsTable .editable-course').forEach(element => {
        element.addEventListener('blur', function() {
            const questionId = this.getAttribute('data-id');
            const field = this.getAttribute('data-field');
            const value = this.innerText.trim();
            
            if (questionId && field) {
                updateCourseQuestionField(questionId, field, value);
            }
        });
        
        element.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.blur();
            }
        });
    });
    
    // Difficulty select listeners
    document.querySelectorAll('#courseQuestionsTable .course-difficulty-select').forEach(select => {
        select.addEventListener('change', function() {
            const questionId = this.getAttribute('data-id');
            const value = this.value;
            
            if (questionId) {
                updateCourseQuestionField(questionId, 'difficulty', value);
            }
        });
    });
    
    // PO select listeners
    document.querySelectorAll('#courseQuestionsTable .course-po-select').forEach(select => {
        select.addEventListener('change', function() {
            const questionId = this.getAttribute('data-id');
            const value = this.value;
            
            if (questionId) {
                updateCourseQuestionField(questionId, 'po_id', value);
            }
        });
    });
    
    // CO select listeners
    document.querySelectorAll('#courseQuestionsTable .course-co-select').forEach(select => {
        select.addEventListener('change', function() {
            const questionId = this.getAttribute('data-id');
            const value = this.value;
            
            if (questionId) {
                updateCourseQuestionField(questionId, 'co_id', value);
            }
        });
    });
    
    // Approve button listeners
    document.querySelectorAll('#courseQuestionsTable .course-approve-btn').forEach(button => {
        button.addEventListener('click', function() {
            const questionId = this.getAttribute('data-id');
            if (questionId) {
                // Show confirmation dialog
                if (confirm('Are you sure you want to APPROVE this question?')) {
                    updateCourseQuestionFlag(questionId, true);
                }
            }
        });
    });
    
    // Reject button listeners
    document.querySelectorAll('#courseQuestionsTable .course-reject-btn').forEach(button => {
         button.addEventListener('click', function() {
            const questionId = this.getAttribute('data-id');
            if (questionId) {
                // Show confirmation dialog
                if (confirm('Are you sure you want to REJECT this question?')) {
                    updateCourseQuestionFlag(questionId, false);
                }
            }
        });
    });
}

// Function to update course question field
async function updateCourseQuestionField(questionId, field, value) {
    try {
        const response = await fetch(`${backendBase}/update_course_question`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                id: parseInt(questionId),
                updates: {
                    [field]: value
                }
            })
        });
        
        const data = await response.json();
        if (data.status === 'success') {
            console.log(`‚úÖ Course Question ${questionId} ${field} updated successfully`);
            showNotification(`Course question ${field} updated successfully`, 'success');
            return true;
        } else {
            console.error('‚ùå Failed to update course question:', data.error);
            showNotification(`Failed to update course question: ${data.error}`, 'error');
            return false;
        }
    } catch (error) {
        console.error('‚ùå Error updating course question:', error);
        showNotification('Error updating course question. Please try again.', 'error');
        return false;
    }
}

// Function to update course question flag (approve/reject)
async function updateCourseQuestionFlag(questionId, flagged) {
  try {
    // Capture current filter state BEFORE updating
    const searchInput = document.getElementById('courseQSearchInput');
    const questionTypeSelect = document.getElementById('courseQQuestionTypeSelect');
    const difficultyFilter = document.getElementById('courseQDifficultyFilter');
    const pdfFilter = document.getElementById('courseQPdfFilter');
    const programFilter = document.getElementById('courseQProgramFilter');
    const courseFilter = document.getElementById('courseQCourseFilter');
    
    const currentSearch = searchInput ? searchInput.value : '';
    const currentType = questionTypeSelect ? questionTypeSelect.value : 'all';
    const currentDifficulty = difficultyFilter ? difficultyFilter.value : 'all';
    const currentPdf = pdfFilter ? pdfFilter.value : '';
    const currentProgram = programFilter ? programFilter.value : '';
    const currentCourse = courseFilter ? courseFilter.value : '';
    
    const response = await fetch(`${backendBase}/update_course_question`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        id: parseInt(questionId),
        updates: {
          flagged: flagged
        }
      })
    });
    
    const data = await response.json();
    if (data.status === 'success') {
      // Reload the questions WITH CURRENT FILTERS
      loadCourseQuestionsFromDB(
        currentSearch,
        currentType,
        currentDifficulty,
        currentProgram,
        currentCourse,
        currentPdf
      );
      showNotification(`Course question ${flagged ? 'approved' : 'rejected'} successfully`, 'success');
    } else {
      console.error('Failed to update course question flag:', data.error);
      showNotification(`Failed to update course question: ${data.error}`, 'error');
    }
  } catch (error) {
    console.error('Error updating course question flag:', error);
    showNotification('Error updating course question status. Please try again.', 'error');
  }
}

// Initialize search functionality for course questions page
function initializeCourseQSearchFunctionality() {
    const searchInput = document.getElementById('courseQSearchInput');
    const questionTypeSelect = document.getElementById('courseQQuestionTypeSelect');
    const difficultyFilter = document.getElementById('courseQDifficultyFilter');
    const searchBtn = document.getElementById('courseQSearchBtn');
    
    // Handle search button click
    if (searchBtn) {
        searchBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const programFilter = document.getElementById('courseQProgramFilter');
            const courseFilter = document.getElementById('courseQCourseFilter');
            
            loadCourseQuestionsFromDB(
                searchInput ? searchInput.value : '',
                questionTypeSelect ? questionTypeSelect.value : 'all',
                difficultyFilter ? difficultyFilter.value : 'all',
                programFilter ? programFilter.value : '',
                courseFilter ? courseFilter.value : ''
            );
        });
    }
    
    // Live search with debounce
    if (searchInput) {
        const doSearch = () => {
            const programFilter = document.getElementById('courseQProgramFilter');
            const courseFilter = document.getElementById('courseQCourseFilter');
            
            loadCourseQuestionsFromDB(
                searchInput.value ? searchInput.value.trim() : '',
                questionTypeSelect ? questionTypeSelect.value : 'all',
                difficultyFilter ? difficultyFilter.value : 'all',
                programFilter ? programFilter.value : '',
                courseFilter ? courseFilter.value : ''
            );
        };
        
        searchInput.addEventListener('input', debounce(doSearch, 300));
    }
    
    // Event listeners for dropdown changes
    if (questionTypeSelect) {
        questionTypeSelect.addEventListener('change', function() {
            const programFilter = document.getElementById('courseQProgramFilter');
            const courseFilter = document.getElementById('courseQCourseFilter');
            
            loadCourseQuestionsFromDB(
                searchInput ? searchInput.value : '',
                this.value,
                difficultyFilter ? difficultyFilter.value : 'all',
                programFilter ? programFilter.value : '',
                courseFilter ? courseFilter.value : ''
            );
        });
    }
    
    if (difficultyFilter) {
        difficultyFilter.addEventListener('change', function() {
            const programFilter = document.getElementById('courseQProgramFilter');
            const courseFilter = document.getElementById('courseQCourseFilter');
            
            loadCourseQuestionsFromDB(
                searchInput ? searchInput.value : '',
                questionTypeSelect ? questionTypeSelect.value : 'all',
                this.value,
                programFilter ? programFilter.value : '',
                courseFilter ? courseFilter.value : ''
            );
        });
    }
}

// Load PDF filter options for course questions
async function loadCourseQPdfFilters() {
    try {
        const response = await fetch(`${backendBase}/course_questions`);
        const questions = await response.json();
        
        const pdfNames = [...new Set(questions.map(q => q.pdf_name).filter(name => name))];
        const pdfFilter = document.getElementById('courseQPdfFilter');
        
        if (pdfFilter) {
            pdfFilter.innerHTML = '<option value="">All PDFs</option>';
            pdfNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                pdfFilter.appendChild(option);
            });
        }
        
        pdfFilter.addEventListener('change', function() {
            const searchInput = document.getElementById('courseQSearchInput');
            const questionTypeSelect = document.getElementById('courseQQuestionTypeSelect');
            const difficultyFilter = document.getElementById('courseQDifficultyFilter');
            const programFilter = document.getElementById('courseQProgramFilter');
            const courseFilter = document.getElementById('courseQCourseFilter');
            
            loadCourseQuestionsFromDB(
                searchInput ? searchInput.value : '',
                questionTypeSelect ? questionTypeSelect.value : 'all',
                difficultyFilter ? difficultyFilter.value : 'all',
                programFilter ? programFilter.value : '',
                courseFilter ? courseFilter.value : ''
            );
        });
    } catch (error) {
        console.error('Error loading PDF filters for course questions:', error);
    }
}

// Update the navigation to handle the new page
document.querySelectorAll('.nav-vertical .btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const pageId = this.getAttribute('data-page');
        if (pageId) {
            document.querySelectorAll('.page').forEach(page => page.style.display = 'none');
            document.getElementById(pageId).style.display = 'block';
            
            if (pageId === 'courseQuestionsPage') {
                console.log('‚òÖ Course Questions page opened');
                
                // Load faculty filters
                loadCourseQFacultyFilters();
                
                // Initialize search functionality
                initializeCourseQSearchFunctionality();
                
                // Load PDF filters
                loadCourseQPdfFilters();
                
                // Load questions initially
                const searchInput = document.getElementById('courseQSearchInput');
                const questionTypeSelect = document.getElementById('courseQQuestionTypeSelect');
                const difficultyFilter = document.getElementById('courseQDifficultyFilter');
                
                loadCourseQuestionsFromDB(
                    searchInput ? searchInput.value : '',
                    questionTypeSelect ? questionTypeSelect.value : 'all',
                    difficultyFilter ? difficultyFilter.value : 'all'
                );
            }
        }
    });
});






  </script>
<! -- End of ========== COURSE SELECTION PAGE FUNCTIONS ========== -->
 
<! -- ========== PDF PAGE FUNCTIONS ========== -->
  <!-- PDF Logic -->
  <script>
    async function uploadAndExtractTOC(file) {
      const fd = new FormData();
      fd.append("file", file, file.name);
      const res = await fetch(`${backendBase}/extract_toc`, { method: "POST", body: fd });
      return res.json();
    }

   // PDF UI wiring
(function initPdf() {
  const pdfInput = document.querySelector('#pdfPage #pdfUploader');
  const pdfBox = pdfInput && pdfInput.closest('.upload-box');
  const statNodes = Array.from(document.querySelectorAll('#pdfPage .stats-card h3') || []);

  function updateDashboardFromResponse(resp) {
    try {
      if (!resp) return;
      if (statNodes[0]) statNodes[0].textContent = (resp.global_state?.pdf_uploads ?? statNodes[0].textContent);
      if (statNodes[1]) statNodes[1].textContent = (typeof resp.pages === 'number' ? resp.pages : (resp.global_state?.last_pdf_pages ?? statNodes[1].textContent));
      if (statNodes[2]) statNodes[2].textContent = (typeof resp.mcqCount === 'number') ? resp.mcqCount : statNodes[2].textContent;
      if (statNodes[3]) statNodes[3].textContent = (typeof resp.descCount === 'number') ? resp.descCount : statNodes[3].textContent;
    } catch (e) {
      console.warn("Failed to update dashboard:", e);
    }
  }

  if (!pdfInput || !pdfBox) return;

   let pdfDoc = null;
  let currentPdfFile = null;

  // Create confirmation modal with larger size for topics
  const confirmationModal = document.createElement('div');
  confirmationModal.className = 'modal fade';
  confirmationModal.id = 'pdfConfirmationModal';
  confirmationModal.innerHTML = `
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title"><i class="bi bi-file-earmark-check"></i> Confirm PDF Upload & Select Topics</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <!-- PDF Preview Section (First) -->
          <div class="mb-4">
            <div class="border rounded p-3" style="background-color: #f8f9fa;">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="mb-0"><i class="bi bi-file-pdf"></i> PDF Preview (Scroll to view all pages)</h6>
                <span class="badge bg-primary" id="pdfPageCount">Loading...</span>
              </div>
              <div id="pdfScrollContainer" style="max-height: 600px; overflow-y: auto; background: #e9ecef; border: 2px solid #dee2e6; border-radius: 5px; padding: 10px;">
                <div id="pdfPagesContainer" style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                  <div class="text-center py-5">
                    <div class="spinner-border text-primary" role="status"></div>
                    <p class="mt-2">Loading PDF...</p>
                  </div>
                </div>
              </div>
              <div class="small text-muted mt-2">
                <i class="bi bi-info-circle"></i> Scroll through the PDF preview above to review content before selecting topics
              </div>
            </div>
          </div>
        <div class="modal-body">
          <div id="pdfInfo"></div>
          <div id="modalTopicsContainer" style="display:none;">
            <hr class="my-3">
            <h6><i class="bi bi-tags"></i> Select Topics:</h6>
            <div class="d-flex justify-content-between align-items-center mb-2">
              <span class="small text-muted" id="modalSelectedCount">0 topics selected</span>
              <div>
                <button type="button" id="modalSelectAll" class="btn btn-sm btn-outline-primary me-1">
                  <i class="bi bi-check-square"></i> Select All
                </button>
                <button type="button" id="modalDeselectAll" class="btn btn-sm btn-outline-secondary">
                  <i class="bi bi-square"></i> Deselect All
                </button>
              </div>
            </div>
            <div id="modalTopicsList" style="max-height: 300px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 5px; padding: 10px; background-color: #f8f9fa;">
            </div>
          </div>
          <div class="alert alert-info mt-2" id="modalInfoMessage">
            <i class="bi bi-info-circle"></i> Analyzing PDF to extract topics...
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <button type="button" class="btn btn-primary" id="confirmContinueBtn" disabled>
            <i class="bi bi-check-lg"></i> Continue
          </button>
        </div>
      </div>
    </div>
  `;
  document.body.appendChild(confirmationModal);
  // Function to render all PDF pages in a scrollable container
  async function renderAllPDFPages() {
    if (!pdfDoc) {
      console.error('No PDF document loaded');
      return;
    }
    
    try {
      const container = document.getElementById('pdfPagesContainer');
      const scrollContainer = document.getElementById('pdfScrollContainer');
      const pageCountBadge = document.getElementById('pdfPageCount');
      
      if (!container) {
        console.error('pdfPagesContainer element not found');
        return;
      }
      
      console.log(`Starting to render ${pdfDoc.numPages} pages`);
      
      container.innerHTML = ''; // Clear loading message
      
      // Update page count badge if it exists
      if (pageCountBadge) {
        pageCountBadge.textContent = `${pdfDoc.numPages} pages`;
      }
      
      const containerWidth = scrollContainer ? (scrollContainer.clientWidth - 40) : 600;
      
      // Render each page
      for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const page = await pdfDoc.getPage(pageNum);
        
        // Create canvas for this page
        const canvas = document.createElement('canvas');
        canvas.className = 'pdf-page-canvas';
        canvas.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
        canvas.style.backgroundColor = 'white';
        canvas.style.maxWidth = '100%';
        canvas.style.height = 'auto';
        
        const ctx = canvas.getContext('2d');
        
        // Calculate scale for clear rendering (higher scale = clearer text)
        const viewport = page.getViewport({ scale: 1 });
        const scale = Math.min(containerWidth / viewport.width, 2.5); // Max scale of 2.5 for clarity
        const scaledViewport = page.getViewport({ scale: scale });
        
        canvas.height = scaledViewport.height;
        canvas.width = scaledViewport.width;
        
        // Add page number label
        const pageWrapper = document.createElement('div');
        pageWrapper.style.position = 'relative';
        pageWrapper.style.width = '100%';
        pageWrapper.style.display = 'flex';
        pageWrapper.style.flexDirection = 'column';
        pageWrapper.style.alignItems = 'center';
        
        const pageLabel = document.createElement('div');
        pageLabel.className = 'badge bg-secondary mb-2';
        pageLabel.textContent = `Page ${pageNum}`;
        pageWrapper.appendChild(pageLabel);
        pageWrapper.appendChild(canvas);
        
        container.appendChild(pageWrapper);
        
        // Render the page
        const renderContext = {
          canvasContext: ctx,
          viewport: scaledViewport
        };
        
        await page.render(renderContext).promise;
        
        // Add a small delay every few pages to prevent UI blocking
        if (pageNum % 3 === 0) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
      
      console.log(`‚úÖ Successfully rendered ${pdfDoc.numPages} pages`);
      
    } catch (error) {
      console.error('Error rendering PDF pages:', error);
      const container = document.getElementById('pdfPagesContainer');
      if (container) {
        container.innerHTML = `
          <div class="alert alert-danger m-3">
            <i class="bi bi-exclamation-triangle"></i> Error loading PDF preview: ${error.message}
          </div>
        `;
      }
    }
  }

  // Function to load PDF
  async function loadPDF(file) {
    try {
      console.log('üìÑ Starting to load PDF:', file.name);
      const arrayBuffer = await file.arrayBuffer();
      pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      
      console.log(`üìÑ PDF loaded successfully: ${pdfDoc.numPages} pages`);
      
      await renderAllPDFPages();
      
    } catch (error) {
      console.error('Error loading PDF:', error);
      const container = document.getElementById('pdfPagesContainer');
      if (container) {
        container.innerHTML = `
          <div class="alert alert-danger m-3">
            <i class="bi bi-exclamation-triangle"></i> Error loading PDF: ${error.message}
          </div>
        `;
      }
    }
  }

  // Build controls area
  const ctrlWrap = document.createElement('div');
  ctrlWrap.className = 'mt-3';
  pdfBox.appendChild(ctrlWrap);

  const statusEl = document.createElement('div'); 
  statusEl.style.marginTop = '8px'; 
  ctrlWrap.appendChild(statusEl);
  
  const topicsInfoEl = document.createElement('div'); 
  topicsInfoEl.style.marginTop = '8px'; 
  ctrlWrap.appendChild(topicsInfoEl);

  // Time estimation display
  const timeEstimateEl = document.createElement('div');
  timeEstimateEl.className = 'mt-2';
  timeEstimateEl.id = 'timeEstimate';
  timeEstimateEl.style.display = 'none';
  timeEstimateEl.innerHTML = `
    <div class="alert alert-warning p-2">
      <div class="d-flex align-items-center">
        <i class="bi bi-clock me-2"></i>
        <div>
          <strong>Estimated Time:</strong> <span id="estimatedTimeText">Calculating...</span>
          <div class="small text-muted" id="timeDetails"></div>
        </div>
      </div>
    </div>
  `;
  ctrlWrap.appendChild(timeEstimateEl);

  // Options form - WITH CONTAINER IDs FOR SHOW/HIDE
  const optionsForm = document.createElement('div');
  optionsForm.id = 'optionsForm';
  optionsForm.style.display = 'none';
  optionsForm.innerHTML = `
    <div class="row g-2 align-items-center mt-3">
      <div class="col-md-4">
        <label class="form-label mb-0"><i class="bi bi-list-check"></i> Question Type</label>
        <select id="questionType" class="form-select">
          <option value="mcq">MCQs Only</option>
          <option value="descriptive">Descriptive Only</option>
          <option value="both" selected>Both MCQs & Descriptive</option>
        </select>
      </div>
      <div class="col-md-4" id="mcqInputContainer">
        <label class="form-label mb-0"><i class="bi bi-question-circle"></i> MCQs per Topic</label>
        <input id="numMcqs" type="number" min="1" max="50" value="0" 
               class="form-control" placeholder="Enter number (1-50)">
        <div class="invalid-feedback">Please enter a valid number (1-50)</div>
      </div>
      <div class="col-md-4" id="descInputContainer">
        <label class="form-label mb-0"><i class="bi bi-pencil"></i> Descriptive per Topic</label>
        <input id="numDesc" type="number" min="1" max="20" value="0" 
               class="form-control" placeholder="Enter number (1-20)">
        <div class="invalid-feedback">Please enter a valid number (1-20)</div>
      </div>
    </div>
  `;
  ctrlWrap.appendChild(optionsForm);

  // Topics selection container
  const topicsContainer = document.createElement('div');
  topicsContainer.className = 'mt-3';
  topicsContainer.id = 'topicsSelectionContainer';
  topicsContainer.style.display = 'none';
  ctrlWrap.appendChild(topicsContainer);

  // Generate button container with time info
  const generateContainer = document.createElement('div');
  generateContainer.className = 'mt-3';
  generateContainer.id = 'generateContainer';
  generateContainer.style.display = 'none';
  generateContainer.innerHTML = `
    <div class="card">
      <div class="card-body">
        <div class="d-grid">
          <button id="generateBtn" class="btn btn-primary btn-lg py-3">
            <i class="bi bi-magic"></i> Generate Questions
          </button>
        </div>
        <div class="mt-2 text-center">
          <small class="text-muted" id="generationTimeNote">
            <i class="bi bi-clock-history"></i> This may take a few minutes
          </small>
        </div>
      </div>
    </div>
  `;
  ctrlWrap.appendChild(generateContainer);

  // Results area
  const resultsArea = document.createElement('div');
  resultsArea.className = 'mt-3';
  pdfBox.appendChild(resultsArea);

  let detectedTopics = [];
  let currentFile = null;
  let selectedTopicCount = 0;
  let currentEstimate = null;
  let preSelectedTopics = [];

  // Function to update time estimate
  async function updateTimeEstimate() {
    if (selectedTopicCount === 0) {
      timeEstimateEl.style.display = 'none';
      return;
    }
    
    const questionType = document.getElementById('questionType').value;
    let numMcqs = 0;
    let numDesc = 0;
    
    // Get values based on question type and ensure they're valid
    if (questionType === 'mcq' || questionType === 'both') {
      const mcqValue = parseInt(document.getElementById('numMcqs').value);
      numMcqs = (!isNaN(mcqValue) && mcqValue > 0) ? mcqValue : 0;
    }
    if (questionType === 'descriptive' || questionType === 'both') {
      const descValue = parseInt(document.getElementById('numDesc').value);
      numDesc = (!isNaN(descValue) && descValue > 0) ? descValue : 0;
    }
    
    try {
      const response = await fetch(`${backendBase}/estimate_generation_time`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          num_topics: selectedTopicCount,
          num_mcqs: numMcqs,
          num_desc: numDesc,
          question_type: questionType
        })
      });
      
      const data = await response.json();
      
      if (data.status === 'success') {
        currentEstimate = data.estimate;
        timeEstimateEl.style.display = 'block';
        
        document.getElementById('estimatedTimeText').textContent = currentEstimate.estimated_time;
        
        const details = currentEstimate.details;
        let detailsText = '';
        
        if (details.total_mcqs > 0) {
          detailsText += `${details.total_mcqs} MCQs`;
        }
        if (details.total_descriptive > 0) {
          if (detailsText) detailsText += ' + ';
          detailsText += `${details.total_descriptive} Descriptive questions`;
        }
        detailsText += ` across ${details.num_topics} topics`;
        
        document.getElementById('timeDetails').textContent = detailsText;
        
        const noteEl = document.getElementById('generationTimeNote');
        noteEl.innerHTML = `<i class="bi bi-clock-history"></i> Estimated time: ${currentEstimate.estimated_time}`;
        
        if (currentEstimate.estimated_seconds > 300) {
          timeEstimateEl.querySelector('.alert').className = 'alert alert-danger p-2';
          noteEl.className = 'text-danger';
        } else if (currentEstimate.estimated_seconds > 120) {
          timeEstimateEl.querySelector('.alert').className = 'alert alert-warning p-2';
          noteEl.className = 'text-warning';
        } else {
          timeEstimateEl.querySelector('.alert').className = 'alert alert-success p-2';
          noteEl.className = 'text-success';
        }
      }
    } catch (error) {
      console.error('Failed to get time estimate:', error);
    }
  }

  function setupQuestionTypeHandler() {
    const questionTypeSelect = document.getElementById('questionType');
    const mcqInputContainer = document.getElementById('mcqInputContainer');
    const descInputContainer = document.getElementById('descInputContainer');
    const numMcqsInput = document.getElementById('numMcqs');
    const numDescInput = document.getElementById('numDesc');

    if (!questionTypeSelect || !mcqInputContainer || !descInputContainer) {
      console.error('Required elements not found for question type handler');
      return;
    }

    function updateInputFieldsVisibility() {
      const selectedType = questionTypeSelect.value;
      
      console.log('Question type changed to:', selectedType);
      
      switch(selectedType) {
        case 'mcq':
          mcqInputContainer.style.display = 'block';
          descInputContainer.style.display = 'none';
          numDescInput.value = '';
          numMcqsInput.value = numMcqsInput.value || '0';
          break;
        case 'descriptive':
          mcqInputContainer.style.display = 'none';
          descInputContainer.style.display = 'block';
          numMcqsInput.value = '';
          numDescInput.value = numDescInput.value || '0';
          break;
        case 'both':
          mcqInputContainer.style.display = 'block';
          descInputContainer.style.display = 'block';
          numMcqsInput.value = numMcqsInput.value || '0';
          numDescInput.value = numDescInput.value || '0';
          break;
      }
      
      // Update time estimate when question type changes
      updateTimeEstimate();
    }

    // Attach the event listener to dropdown
    questionTypeSelect.addEventListener('change', updateInputFieldsVisibility);
    
    // Add event listeners to input fields to update estimate on value change
    numMcqsInput.addEventListener('input', debounce(updateTimeEstimate, 500));
    numDescInput.addEventListener('input', debounce(updateTimeEstimate, 500));

    // Initialize visibility on load
    updateInputFieldsVisibility();
  }

  // PDF upload handler
   pdfInput.addEventListener('change', async (e) => {
    resultsArea.innerHTML = '';
    topicsContainer.innerHTML = '';
    topicsInfoEl.innerHTML = '';
    timeEstimateEl.style.display = 'none';
    optionsForm.style.display = 'none';
    topicsContainer.style.display = 'none';
    generateContainer.style.display = 'none';
    
    const f = e.target.files[0];
    if (!f) return;
    
    currentFile = f;
    currentPdfFile = f;
    
    // Create and show modal
    const modalElement = document.getElementById('pdfConfirmationModal');
    const modal = new bootstrap.Modal(modalElement);
    modal.show();
    
    // Wait for modal animation to complete
    modalElement.addEventListener('shown.bs.modal', async function onShown() {
      // Remove listener after first call
      modalElement.removeEventListener('shown.bs.modal', onShown);
      
      console.log('Modal is now shown, loading PDF...');
      
      // Now it's safe to access modal elements
      const pdfInfo = document.getElementById('pdfInfo');
      if (pdfInfo) {
        const fileSizeMB = (f.size / 1024 / 1024).toFixed(2);
        pdfInfo.innerHTML = `
          <div class="alert alert-success">
            <div class="d-flex align-items-center">
              <i class="bi bi-file-earmark-pdf fs-4 me-3 text-danger"></i>
              <div>
                <h6 class="mb-1">${f.name}</h6>
                <div class="small">Size: ${fileSizeMB} MB</div>
              </div>
            </div>
          </div>
        `;
      }
      
      // Load PDF
      await loadPDF(f);
      
      // Extract topics
      const modalInfoMessage = document.getElementById('modalInfoMessage');
      const modalTopicsContainer = document.getElementById('modalTopicsContainer');
      const confirmBtn = document.getElementById('confirmContinueBtn');
      
      if (modalInfoMessage) {
        modalInfoMessage.innerHTML = `
          <div class="d-flex align-items-center">
            <div class="spinner-border spinner-border-sm me-2" role="status"></div>
            <div><i class="bi bi-info-circle"></i> Analyzing PDF to extract topics...</div>
          </div>
        `;
      }
      
      if (confirmBtn) {
        confirmBtn.disabled = true;
      }
      
      try {
        const r = await uploadAndExtractTOC(f);
        if (r.status === 'success') {
          detectedTopics = r.matches || [];
          
          if (detectedTopics.length > 0) {
            if (modalInfoMessage) modalInfoMessage.style.display = 'none';
            if (modalTopicsContainer) modalTopicsContainer.style.display = 'block';
            
            renderModalTopics();
            
            if (confirmBtn) confirmBtn.disabled = false;
          } else {
            if (modalInfoMessage) {
              modalInfoMessage.className = 'alert alert-warning mt-2';
              modalInfoMessage.innerHTML = '<i class="bi bi-exclamation-triangle"></i> No topics detected in the PDF. Please try a different PDF.';
            }
            if (confirmBtn) confirmBtn.disabled = true;
          }
        } else {
          if (modalInfoMessage) {
            modalInfoMessage.className = 'alert alert-danger mt-2';
            modalInfoMessage.innerHTML = `<i class="bi bi-exclamation-triangle"></i> PDF analysis failed: ${r.error || 'unknown error'}`;
          }
          if (confirmBtn) confirmBtn.disabled = true;
        }
      } catch (err) {
        if (modalInfoMessage) {
          modalInfoMessage.className = 'alert alert-danger mt-2';
          modalInfoMessage.innerHTML = `<i class="bi bi-exclamation-triangle"></i> Error: ${err.message || err}`;
        }
        if (confirmBtn) confirmBtn.disabled = true;
      }
    });
  });
  // Function to render topics in the modal
  function renderModalTopics() {
    const modalTopicsList = document.getElementById('modalTopicsList');
    const modalSelectedCount = document.getElementById('modalSelectedCount');
    
    modalTopicsList.innerHTML = '';
    
    detectedTopics.forEach((topic, idx) => {
      const topicItem = document.createElement('div');
      topicItem.className = 'mb-2 p-2 border rounded topic-item';
      topicItem.style.backgroundColor = '#fff';
      topicItem.style.transition = 'background-color 0.2s';
      
      const pageInfo = topic.page ? `<small class="text-muted"><i class="bi bi-file-earmark"></i> Page ${topic.page}</small>` : '';
      
      topicItem.innerHTML = `
        <div class="form-check">
          <input class="form-check-input modal-topic-checkbox" type="checkbox" 
                 value="${topic.title}" 
                 id="modal_topic_${idx}"
                 data-page="${topic.page || ''}">
          <label class="form-check-label w-100" for="modal_topic_${idx}" style="cursor: pointer;">
            <div class="d-flex justify-content-between align-items-start">
              <div>
                <strong>${topic.title || 'Untitled Topic'}</strong>
                <div class="small">
                  ${pageInfo}
                </div>
              </div>
            </div>
          </label>
        </div>
      `;
      
      modalTopicsList.appendChild(topicItem);
      
      topicItem.addEventListener('mouseenter', () => {
        topicItem.style.backgroundColor = '#f0f8ff';
      });
      topicItem.addEventListener('mouseleave', () => {
        const checkbox = topicItem.querySelector('.modal-topic-checkbox');
        topicItem.style.backgroundColor = checkbox?.checked ? '#e7f4ff' : '#fff';
      });
    });
    
    document.getElementById('modalSelectAll').onclick = () => {
      modalTopicsList.querySelectorAll('.modal-topic-checkbox').forEach(cb => {
        cb.checked = true;
        cb.closest('.topic-item').style.backgroundColor = '#e7f4ff';
      });
      updateModalSelectedCount();
    };
    
    document.getElementById('modalDeselectAll').onclick = () => {
      modalTopicsList.querySelectorAll('.modal-topic-checkbox').forEach(cb => {
        cb.checked = false;
        cb.closest('.topic-item').style.backgroundColor = '#fff';
      });
      updateModalSelectedCount();
    };
    
    modalTopicsList.querySelectorAll('.modal-topic-checkbox').forEach(cb => {
      cb.addEventListener('change', function() {
        this.closest('.topic-item').style.backgroundColor = this.checked ? '#e7f4ff' : '#fff';
        updateModalSelectedCount();
      });
    });
    
    function updateModalSelectedCount() {
      const selected = modalTopicsList.querySelectorAll('.modal-topic-checkbox:checked').length;
      const total = detectedTopics.length;
      modalSelectedCount.textContent = `${selected} of ${total} topics selected`;
    }
    
    updateModalSelectedCount();
  }

  // Handle confirmation to continue
  document.getElementById('confirmContinueBtn').addEventListener('click', async () => {
    const modalTopicsList = document.getElementById('modalTopicsList');
    const selectedCheckboxes = modalTopicsList.querySelectorAll('.modal-topic-checkbox:checked');
    
    if (selectedCheckboxes.length === 0) {
      alert('Please select at least one topic to continue.');
      return;
    }
    
    preSelectedTopics = Array.from(selectedCheckboxes).map(cb => cb.value);
    
    const modal = bootstrap.Modal.getInstance(document.getElementById('pdfConfirmationModal'));
    modal.hide();
    
    statusEl.innerHTML = `<div class="alert alert-success">
      <i class="bi bi-check-circle"></i> PDF analyzed successfully. Found ${preSelectedTopics.length} selected topics. 
      You selected <strong>${preSelectedTopics.length}</strong> topics from the PDF.
      <div class="small mt-1">Review your selection below</div>
    </div>`;
    
    optionsForm.style.display = 'block';
    
    // *** CALL THE SETUP FUNCTION AFTER OPTIONS FORM IS DISPLAYED ***
    setupQuestionTypeHandler();
    
    renderTopicsSelection();
    generateContainer.style.display = 'block';
  });

   // Reset UI function
  function resetUI() {
    optionsForm.style.display = 'none';
    topicsContainer.style.display = 'none';
    generateContainer.style.display = 'none';
    timeEstimateEl.style.display = 'none';
    detectedTopics = [];
    currentFile = null;
    selectedTopicCount = 0;
    currentEstimate = null;
    preSelectedTopics = []; // Clear pre-selected topics
  }

  // Render topics selection UI
  function renderTopicsSelection() {
    topicsContainer.innerHTML = '';
    topicsContainer.style.display = 'block';
    
    const filteredTopics = detectedTopics.filter(topic => 
      preSelectedTopics.includes(topic.title)
    );
    
    if (filteredTopics.length === 0) {
      topicsContainer.innerHTML = `<div class="alert alert-warning">
        <i class="bi bi-exclamation-triangle"></i> No topics were selected. Please upload the PDF again.
      </div>`;
      return;
    }
    
    const header = document.createElement('div');
    header.className = 'mb-3';
    header.innerHTML = `
      <h6 class="mb-2"><i class="bi bi-tags"></i> Selected Topics for Question Generation:</h6>
      <div class="d-flex justify-content-between align-items-center mb-2">
        <span class="small text-muted" id="selectedTopicsCount">${filteredTopics.length} topics (all pre-selected)</span>
        <div>
          <button id="selectAllTopics" class="btn btn-sm btn-outline-primary me-1">
            <i class="bi bi-check-square"></i> Select All
          </button>
          <button id="deselectAllTopics" class="btn btn-sm btn-outline-secondary">
            <i class="bi bi-square"></i> Deselect All
          </button>
        </div>
      </div>
    `;
    topicsContainer.appendChild(header);
    
    const topicsList = document.createElement('div');
    topicsList.className = 'topics-list-container';
    topicsList.style.maxHeight = '300px';
    topicsList.style.overflowY = 'auto';
    topicsList.style.border = '1px solid #dee2e6';
    topicsList.style.borderRadius = '5px';
    topicsList.style.padding = '10px';
    topicsList.style.backgroundColor = '#f8f9fa';
    
    filteredTopics.forEach((topic, idx) => {
      const topicItem = document.createElement('div');
      topicItem.className = 'mb-2 p-2 border rounded topic-item';
      topicItem.style.backgroundColor = '#e7f4ff';
      topicItem.style.transition = 'background-color 0.2s';
      
      const pageInfo = topic.page ? `<small class="text-muted"><i class="bi bi-file-earmark"></i> Page ${topic.page}</small>` : '';
      
      topicItem.innerHTML = `
        <div class="form-check">
          <input class="form-check-input topic-checkbox" type="checkbox" 
                 value="${topic.title}" 
                 id="topic_${idx}"
                 data-page="${topic.page || ''}"
                 checked>
          <label class="form-check-label w-100" for="topic_${idx}" style="cursor: pointer;">
            <div class="d-flex justify-content-between align-items-start">
              <div>
                <strong>${topic.title || 'Untitled Topic'}</strong>
                <div class="small">
                  ${pageInfo}
                </div>
              </div>
            </div>
          </label>
        </div>
      `;
      
      topicsList.appendChild(topicItem);
      
      topicItem.addEventListener('mouseenter', () => {
        topicItem.style.backgroundColor = '#f0f8ff';
      });
      topicItem.addEventListener('mouseleave', () => {
        const checkbox = topicItem.querySelector('.topic-checkbox');
        topicItem.style.backgroundColor = checkbox?.checked ? '#e7f4ff' : '#fff';
      });
    });
    
    topicsContainer.appendChild(topicsList);
    
    document.getElementById('selectAllTopics').addEventListener('click', () => {
      topicsList.querySelectorAll('.topic-checkbox').forEach(cb => {
        cb.checked = true;
        cb.closest('.topic-item').style.backgroundColor = '#e7f4ff';
      });
      updateSelectedTopicsCount();
      updateTimeEstimate();
    });
    
    document.getElementById('deselectAllTopics').addEventListener('click', () => {
      topicsList.querySelectorAll('.topic-checkbox').forEach(cb => {
        cb.checked = false;
        cb.closest('.topic-item').style.backgroundColor = '#fff';
      });
      updateSelectedTopicsCount();
      updateTimeEstimate();
    });
    
    topicsList.querySelectorAll('.topic-checkbox').forEach(cb => {
      cb.addEventListener('change', function() {
        this.closest('.topic-item').style.backgroundColor = this.checked ? '#e7f4ff' : '#fff';
        updateSelectedTopicsCount();
        updateTimeEstimate();
      });
    });
    
    function updateSelectedTopicsCount() {
      selectedTopicCount = topicsList.querySelectorAll('.topic-checkbox:checked').length;
      const total = filteredTopics.length;
      document.getElementById('selectedTopicsCount').textContent = 
        `${selectedTopicCount} of ${total} topics selected`;
    }
    
    updateSelectedTopicsCount();
    updateTimeEstimate();
  }

  // Generate questions button handler
  document.getElementById('generateBtn').addEventListener('click', async () => {
  const questionType = document.getElementById('questionType').value;
  const numMcqsInput = document.getElementById('numMcqs');
  const numDescInput = document.getElementById('numDesc');
  let numMcqs = parseInt(numMcqsInput.value);
  let numDesc = parseInt(numDescInput.value);
  
  numMcqsInput.classList.remove('is-invalid');
  numDescInput.classList.remove('is-invalid');
  
  let isValid = true;
  
  if (questionType === 'mcq' || questionType === 'both') {
    if (isNaN(numMcqs) || numMcqs < 1 || numMcqs > 50) {
      numMcqsInput.classList.add('is-invalid');
      alert('Please enter a valid number of MCQs per topic (1-50)');
      isValid = false;
    }
  } else {
    numMcqs = 0;
  }
  
  if (questionType === 'descriptive' || questionType === 'both') {
    if (isNaN(numDesc) || numDesc < 1 || numDesc > 20) {
      numDescInput.classList.add('is-invalid');
      alert('Please enter a valid number of descriptive questions per topic (1-20)');
      isValid = false;
    }
  } else {
    numDesc = 0;
  }
  
  if (selectedTopicCount === 0) {
    alert('Please select at least one topic for question generation.');
    isValid = false;
  }
  
  if (!isValid) return;
  
  if (currentEstimate) {
    let confirmMessage = `You are about to generate questions for ${selectedTopicCount} topics.\n\n`;
    confirmMessage += `‚Ä¢ ${selectedTopicCount} topics\n`;
    
    if (questionType === 'mcq' || questionType === 'both') {
      confirmMessage += `‚Ä¢ ${numMcqs} MCQs per topic\n`;
    }
    if (questionType === 'descriptive' || questionType === 'both') {
      confirmMessage += `‚Ä¢ ${numDesc} descriptive questions per topic\n`;
    }
    
    confirmMessage += `\nEstimated time: ${currentEstimate.estimated_time}\n\n`;
    confirmMessage += `Do you want to continue?`;
    
    const confirmed = confirm(confirmMessage);
    if (!confirmed) return;
  }
  
  const checkedBoxes = topicsContainer.querySelectorAll('.topic-checkbox:checked');
  const selectedTopicTitles = Array.from(checkedBoxes).map(cb => cb.value);
  const qType = questionType;
  
  // Show modal
  const progressModal = new bootstrap.Modal(document.getElementById('generationProgressModal'));
  progressModal.show();
  
  const startTime = Date.now();
  let timeoutReached = false;
  let userCancelled = false;
  let abortController = new AbortController();
  // Set up cancel button handler
  const cancelBtn = document.getElementById('cancelGenerationBtn');
  if (cancelBtn) {
    cancelBtn.onclick = () => {
      userCancelled = true;
      abortController.abort();
      progressModal.hide();
      resultsArea.innerHTML = `
        <div class="alert alert-warning">
          <i class="bi bi-exclamation-triangle"></i> Generation cancelled by user.
        </div>
      `;
    };
  }
  
  // Update elapsed time
  const timeUpdateInterval = setInterval(() => {
    if (userCancelled) {
      clearInterval(timeUpdateInterval);
      return;
    }
    
    const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
    const minutes = Math.floor(elapsedSeconds / 60);
    const seconds = elapsedSeconds % 60;
    const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
    
    const elapsedEl = document.getElementById('elapsedTime');
    if (elapsedEl) elapsedEl.textContent = timeStr;
    
    const progressText = document.getElementById('generationProgressText');
    if (progressText) {
      progressText.textContent = `Processing ${selectedTopicCount} topics...`;
    }
    
    // Check if timeout reached
    if (currentEstimate && elapsedSeconds > currentEstimate.estimated_seconds && !timeoutReached) {
      timeoutReached = true;
      showTimeoutWarning();
    }
  }, 1000);
  // Helper function to generate hash from string
  async function generateHash(str) {
    const encoder = new TextEncoder();
    const data = encoder.encode(str);
    const hashBuffer = await crypto.subtle.digest('MD5', data).catch(() => {
      // Fallback for browsers without crypto.subtle
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return hash.toString(36);
    });
    
    if (typeof hashBuffer === 'string') return hashBuffer;
    
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }
  
  function showTimeoutWarning() {
    const warningEl = document.getElementById('timeoutWarning');
    const footerEl = document.getElementById('generationModalFooter');
    
    if (warningEl) warningEl.style.display = 'block';
    
    if (footerEl) {
      footerEl.innerHTML = `
        <button type="button" class="btn btn-secondary" id="cancelGenerationBtn">
          <i class="bi bi-x-circle"></i> Cancel
        </button>
        <button type="button" class="btn btn-primary" id="continueGenerationBtn">
          <i class="bi bi-check-circle"></i> Continue Waiting
        </button>
      `;
      
      document.getElementById('cancelGenerationBtn').addEventListener('click', () => {
        userCancelled = true;
        abortController.abort();
        clearInterval(timeUpdateInterval);
        progressModal.hide();
        resultsArea.innerHTML = `
          <div class="alert alert-warning">
            <i class="bi bi-exclamation-triangle"></i> Generation cancelled by user.
          </div>
        `;
      });
      
      document.getElementById('continueGenerationBtn').addEventListener('click', () => {
        if (warningEl) warningEl.style.display = 'none';
        footerEl.innerHTML = '';
        timeoutReached = false;
      });
    }
  }
  
  try {
    const fd = new FormData();
    fd.append("file", currentFile, currentFile.name);
    fd.append("topics", JSON.stringify(selectedTopicTitles));
    fd.append("question_type", qType);
    fd.append("num_mcqs", String(numMcqs));
    fd.append("num_desc", String(numDesc));
    
    const response = await fetch(`${backendBase}/generate_pdf_mcqs`, { 
      method: "POST", 
      body: fd,
      signal: abortController.signal
    });
    
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    
    const r = await response.json();
    
    clearInterval(timeUpdateInterval);
    progressModal.hide();
    
    const endTime = Date.now();
    const actualSeconds = Math.floor((endTime - startTime) / 1000);
    const actualMinutes = Math.floor(actualSeconds / 60);
    const actualRemainingSeconds = actualSeconds % 60;
    const actualTime = actualMinutes > 0 ? 
      `${actualMinutes}m ${actualRemainingSeconds}s` : 
      `${actualSeconds}s`;
    
    if (r.status === 'success') {
      resultsArea.innerHTML = `
        <div class="alert alert-success">
          <div class="d-flex align-items-center">
            <i class="bi bi-check-circle-fill fs-4 me-3"></i>
            <div>
              <strong>Generation completed successfully!</strong>
              <div class="small">
                Generated questions for ${r.results_count_topics} topics in ${actualTime}
                ${currentEstimate ? `(Estimated: ${currentEstimate.estimated_time})` : ''}
              </div>
            </div>
          </div>
        </div>
      `;
      
      updateDashboardFromResponse(r);

        // Display results header
        const header = document.createElement('div'); 
        header.className='mb-3 p-3 bg-light rounded';
        header.innerHTML = `
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <h6 class="mb-1"><i class="bi bi-file-text"></i> Generated Questions</h6>
              <div class="small">
                <span class="badge bg-primary">${Object.keys(r.results || {}).length} Topics</span>
                <span class="badge bg-success ms-1">${r.mcqCount || 0} MCQs</span>
                <span class="badge bg-warning ms-1">${r.descCount || 0} Descriptive</span>
                <span class="badge bg-info ms-1">Time: ${actualTime}</span>
              </div>
            </div>
            <div>
              <span class="small text-muted">Pages: ${r.pages || 0}</span>
            </div>
          </div>
          <div class="small mt-2">
            <strong>Selected Topics:</strong> ${r.selected_topics?.slice(0, 3).join(', ') || 'N/A'}
            ${r.selected_topics?.length > 3 ? `and ${r.selected_topics.length - 3} more...` : ''}
          </div>
        `;
        resultsArea.appendChild(header);

        // Download buttons
        const dlRow = document.createElement('div'); 
        dlRow.className='mb-3';
        const keys = r.download_keys || {};
        
        const createDownloadBtn = (key, text, icon, color) => {
          if (key) {
            const a = document.createElement('a'); 
            a.href = `${backendBase}/download/${key}`; 
            a.className=`btn btn-${color} btn-sm me-2`;
            a.innerHTML = `<i class="bi ${icon}"></i> ${text}`; 
            return a;
          }
          return null;
        };
        
        [createDownloadBtn(keys.docx, 'Download DOCX', 'bi-file-word', 'primary'),
         createDownloadBtn(keys.excel, 'Download Excel', 'bi-file-excel', 'success'),
         createDownloadBtn(keys.csv, 'Download CSV', 'bi-file-earmark-text', 'secondary')]
        .filter(Boolean)
        .forEach(btn => dlRow.appendChild(btn));

        // Export to Database button
       const exportBtn = document.createElement('button');
        exportBtn.className = 'btn btn-warning btn-sm me-2';
        exportBtn.innerHTML = '<i class="bi bi-database"></i> Export to Database';
        exportBtn.addEventListener('click', async () => {
          exportBtn.disabled = true;
          exportBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Exporting...';
          try {
            // Generate hash for results to track exports
            const resultStr = JSON.stringify(r.results || {});
            const resultHash = await generateHash(resultStr);
            
            // Check if already exported
            const checkResp = await fetch(`${backendBase}/check_export_status`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ result_hash: resultHash })
            });
            const checkData = await checkResp.json();
            
            if (checkData.is_exported) {
              alert('‚úÖ These questions have already been exported to the database!');
              exportBtn.innerHTML = '<i class="bi bi-check-circle"></i> Already Exported';
              exportBtn.classList.remove('btn-warning');
              exportBtn.classList.add('btn-success');
              exportBtn.disabled = true;
              return;
            }
            
            // Proceed with export - INCLUDE PDF NAME
            const resp = await fetch(`${backendBase}/save_questions_to_db`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                results: r.results || {},
                pdf_name: currentFile ? currentFile.name : ''  // ADD THIS LINE
              }),
            });
            const data = await resp.json();
            
            if (data.status === 'success') {
              let msg = `‚úÖ Export completed successfully!\n\n` +
                        `Saved: ${data.saved || 0}\n` +
                        `Duplicates skipped: ${data.duplicates || 0}\n` +
                        `Invalid questions skipped: ${data.skipped || 0}`;
              alert(msg);
              
              // Update button to show exported
              exportBtn.innerHTML = '<i class="bi bi-check-circle"></i> Already Exported';
              exportBtn.classList.remove('btn-warning');
              exportBtn.classList.add('btn-success');
              exportBtn.disabled = true;
            } else if (data.status === 'already_exported') {
              alert('‚úÖ These questions have already been exported to the database!');
              exportBtn.innerHTML = '<i class="bi bi-check-circle"></i> Already Exported';
              exportBtn.classList.remove('btn-warning');
              exportBtn.classList.add('btn-success');
              exportBtn.disabled = true;
            } else {
              alert('‚ùå Export failed: ' + (data.error || 'Unknown error'));
              exportBtn.disabled = false;
              exportBtn.innerHTML = '<i class="bi bi-database"></i> Export to Database';
            }
          } catch (err) {
            alert('‚ö†Ô∏è Error exporting questions: ' + err.message);
            exportBtn.disabled = false;
            exportBtn.innerHTML = '<i class="bi bi-database"></i> Export to Database';
          }
        });
        dlRow.appendChild(exportBtn);

        resultsArea.appendChild(dlRow);

        // Display topics with questions in accordion
        const results = r.results || {};
        if (Object.keys(results).length > 0) {
          const accordion = document.createElement('div');
          accordion.className = 'accordion';
          accordion.id = 'questionsAccordion';
          
          Object.entries(results).forEach(([topicTitle, data], idx) => {
            const mcqs = data.mcqs || [];
            const descs = data.descriptive || [];
            const hasMCQs = mcqs.length > 0 && qType !== 'descriptive';
            const hasDescriptive = descs.length > 0 && qType !== 'mcq';
            
            if (!hasMCQs && !hasDescriptive) return;
            
            const itemId = `topic_${idx}`;
            const collapseId = `collapse_${idx}`;
            
            const item = document.createElement('div');
            item.className = 'accordion-item';
            item.innerHTML = `
              <h2 class="accordion-header" id="${itemId}">
                <button class="accordion-button collapsed" type="button" 
                        data-bs-toggle="collapse" data-bs-target="#${collapseId}"
                        aria-expanded="false" aria-controls="${collapseId}">
                  <div class="d-flex w-100 justify-content-between align-items-center">
                    <span>${topicTitle}</span>
                    <div class="small">
                      ${hasMCQs ? `<span class="badge bg-success">${mcqs.length} MCQs</span>` : ''}
                      ${hasDescriptive ? `<span class="badge bg-warning ms-1">${descs.length} Descriptive</span>` : ''}
                    </div>
                  </div>
                </button>
              </h2>
              <div id="${collapseId}" class="accordion-collapse collapse" 
                   aria-labelledby="${itemId}" data-bs-parent="#questionsAccordion">
                <div class="accordion-body">
                  <div class="topic-questions-content"></div>
                </div>
              </div>
            `;
            
            accordion.appendChild(item);
            
            // Add questions to the content
            const contentDiv = item.querySelector('.topic-questions-content');
            
            if (hasMCQs) {
              const mcqSection = document.createElement('div');
              mcqSection.className = 'mb-4';
              mcqSection.innerHTML = `<h6 class="border-bottom pb-2">Multiple Choice Questions:</h6>`;
              
              mcqs.forEach((mcq, mIdx) => {
                const mcqDiv = document.createElement('div');
                mcqDiv.className = 'mb-3 p-3 border rounded';
                mcqDiv.innerHTML = `
                  <div class="fw-bold mb-2">${mIdx + 1}. ${mcq.question || ''}</div>
                  <div class="ms-3">
                    ${(mcq.options || []).map(opt => `<div class="mb-1">${opt}</div>`).join('')}
                  </div>
                  ${mcq.answer ? `<div class="text-success mt-2"><strong>Answer:</strong> ${mcq.answer}</div>` : ''}
                  ${mcq.difficulty ? `<div class="text-muted small mt-1"><strong>Difficulty:</strong> ${mcq.difficulty}</div>` : ''}
                `;
                mcqSection.appendChild(mcqDiv);
              });
              contentDiv.appendChild(mcqSection);
            }
            
            if (hasDescriptive) {
              const descSection = document.createElement('div');
              descSection.className = 'mt-4';
              descSection.innerHTML = `<h6 class="border-bottom pb-2">Descriptive Questions:</h6>`;
              
              descs.forEach((desc, dIdx) => {
                const descDiv = document.createElement('div');
                descDiv.className = 'mb-3 p-3 border rounded';
                const q = typeof desc === 'string' ? desc : (desc.question || '');
                const a = typeof desc === 'object' ? (desc.answer || '') : '';
                const diff = typeof desc === 'object' ? (desc.difficulty || '') : '';
                
                descDiv.innerHTML = `
                  <div class="fw-bold mb-2">${dIdx + 1}. ${q}</div>
                  ${a ? `<div class="text-success mt-2"><strong>Answer:</strong> ${a}</div>` : ''}
                  ${diff ? `<div class="text-muted small mt-1"><strong>Difficulty:</strong> ${diff}</div>` : ''}
                `;
                descSection.appendChild(descDiv);
              });
              contentDiv.appendChild(descSection);
            }
          });
          
          resultsArea.appendChild(accordion);
        } else {
          resultsArea.innerHTML += `<div class="alert alert-warning">
            No questions were generated. Please try with different topics or settings.
          </div>`;
        }
        
      } else {
        clearInterval(progressTimer);
        statusEl.innerHTML = `<div class="alert alert-danger">
          <i class="bi bi-exclamation-triangle"></i> Generation failed: ${r.error || 'Unknown error'}
        </div>`;
      }
    } catch (err) {
      clearInterval(progressTimer);
      statusEl.innerHTML = `<div class="alert alert-danger">
        <i class="bi bi-exclamation-triangle"></i> Error: ${err.message || err}
      </div>`;
    } finally {
      btn.disabled = false; 
      btn.innerHTML = originalText;
    }
  });

  // Real-time validation for input fields
  document.addEventListener('input', function(e) {
    if (e.target.id === 'numMcqs') {
      const value = parseInt(e.target.value);
      if (isNaN(value) || value < 1 || value > 50) {
        e.target.classList.add('is-invalid');
      } else {
        e.target.classList.remove('is-invalid');
      }
    }
    
    if (e.target.id === 'numDesc') {
      const value = parseInt(e.target.value);
      if (isNaN(value) || value < 1 || value > 20) {
        e.target.classList.add('is-invalid');
      } else {
        e.target.classList.remove('is-invalid');
      }
    }
  });
})();


  </script> 

  <! -- END OF  ========== PDF PAGE FUNCTIONS ========== -->


  
  <!-- === FULL VIDEO LOGIC (from original) === -->
  <!-- Confirmation Modal -->
<div id="confirmationModal" class="modal fade" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="modalTitle">Confirmation</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body" id="modalBody">
        <!-- Content will be inserted here -->
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="modalConfirmBtn">Confirm</button>
      </div>
    </div>
  </div>
</div>

<!-- Processing Modal -->
<div id="processingModal" class="modal fade" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="processingTitle">Processing</h5>
      </div>
      <div class="modal-body" id="processingBody">
        <!-- Content will be inserted here -->
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-danger" id="cancelProcessingBtn">Cancel</button>
      </div>
    </div>
  </div>
</div>
 <script>
    document.addEventListener('DOMContentLoaded', () => {
      // note: uses shared backendBase variable defined earlier
      const statNodes = Array.from(document.querySelectorAll('#videoPage .stats-card h3') || []);
      
      // Variables for tracking ongoing processes
      let currentProcess = null; // 'transcribe' or 'generate'
      let abortController = null;

      function updateDashboardFromResponse(resp) {
        try {
          if (!resp) return;
          // update video uploads
          const vUploads = (resp.global_state && typeof resp.global_state.video_uploads === 'number')
                            ? resp.global_state.video_uploads
                            : (typeof resp.video_uploads === 'number' ? resp.video_uploads : undefined);
          if (typeof vUploads === 'number') {
            const el = document.getElementById('videoUploadsStat');
            if (el) el.textContent = vUploads;
          }
          // update MCQs generated (per-request or global)
          const mcqsNow = (typeof resp.mcqCount === 'number') ? resp.mcqCount : resp.global_state?.mcq_count;
          if (typeof mcqsNow === 'number') {
            const el2 = document.getElementById('videoMcqStat');
            if (el2) el2.textContent = mcqsNow;
          }
        } catch (e) {
          console.warn("updateDashboardFromResponse failed", e);
        }
      }

      async function transcribeVideo(file, whisper_model="small") {
        abortController = new AbortController();
        const fd = new FormData();
        fd.append("file", file, file.name);
        fd.append("whisper_model", whisper_model);
        
        try {
          const r = await fetch(`${backendBase}/transcribe_video`, { 
            method: "POST", 
            body: fd,
            signal: abortController.signal
          });
          const json = await r.json().catch(()=>({status:"error", error:"invalid_json_response"}));
          return json;
        } catch (error) {
          if (error.name === 'AbortError') {
            return {status: "cancelled", error: "Transcription cancelled by user"};
          }
          return {status: "error", error: error.message};
        }
      }

      async function generateVideoMCQs({file=null, summary="", questionType="both", numQs=0}) {
        abortController = new AbortController();
        const fd = new FormData();
        if (file) fd.append("file", file, file.name);
        fd.append("summary", summary || "");
        fd.append("question_type", questionType);
        fd.append("num_qs", String(numQs));
        
        try {
          const r = await fetch(`${backendBase}/generate_video_mcqs`, { 
            method: "POST", 
            body: fd,
            signal: abortController.signal
          });
          const json = await r.json().catch(()=>({status:"error", error:"invalid_json_response"}));
          return json;
        } catch (error) {
          if (error.name === 'AbortError') {
            return {status: "cancelled", error: "Generation cancelled by user"};
          }
          return {status: "error", error: error.message};
        }
      }

      // Show confirmation modal
      function showConfirmation(action, callback) {
        const modal = new bootstrap.Modal(document.getElementById('confirmationModal'));
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');
        
        if (action === 'transcribe') {
          modalTitle.textContent = 'Confirm Transcription';
          modalBody.innerHTML = `
            <p>Are you sure you want to transcribe this video?</p>
            <p class="text-muted small">This process may take several minutes depending on the video length.</p>
          `;
          modalConfirmBtn.textContent = 'Transcribe';
        } else if (action === 'generate') {
          modalTitle.textContent = 'Generate MCQs';
          modalBody.innerHTML = `
            <p>Are you sure you want to generate MCQs from the transcript?</p>
            <p class="text-muted small">This will generate questions based on the transcribed content.</p>
          `;
          modalConfirmBtn.textContent = 'Generate';
        }
        
        // Remove previous event listeners
        const newConfirmBtn = modalConfirmBtn.cloneNode(true);
        modalConfirmBtn.parentNode.replaceChild(newConfirmBtn, modalConfirmBtn);
        
        // Add new event listener
        newConfirmBtn.addEventListener('click', () => {
          modal.hide();
          showProcessingModal(action);
          callback();
        });
        
        modal.show();
      }

      // Show processing modal
      function showProcessingModal(action) {
        const modal = new bootstrap.Modal(document.getElementById('processingModal'));
        const processingTitle = document.getElementById('processingTitle');
        const processingBody = document.getElementById('processingBody');
        const cancelBtn = document.getElementById('cancelProcessingBtn');
        
        if (action === 'transcribe') {
          processingTitle.textContent = 'Transcribing Video';
          processingBody.innerHTML = `
            <div class="text-center">
              <div class="spinner-border text-primary mb-3" role="status">
                <span class="visually-hidden">Loading...</span>
              </div>
              <p>Transcribing video content. This may take several minutes...</p>
              <p class="text-muted small">Please do not close this window.</p>
            </div>
          `;
        } else if (action === 'generate') {
          processingTitle.textContent = 'Generating MCQs';
          processingBody.innerHTML = `
            <div class="text-center">
              <div class="spinner-border text-primary mb-3" role="status">
                <span class="visually-hidden">Loading...</span>
              </div>
              <p>Generating multiple choice questions from the transcript...</p>
              <p class="text-muted small">Please do not close this window.</p>
            </div>
          `;
        }
        
        // Update cancel button
        cancelBtn.textContent = action === 'transcribe' ? 'Cancel Transcription' : 'Cancel Generation';
        
        // Remove previous event listeners
        const newCancelBtn = cancelBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
        
        // Add cancel event listener
        newCancelBtn.addEventListener('click', () => {
          if (abortController) {
            abortController.abort();
          }
          const modal = bootstrap.Modal.getInstance(document.getElementById('processingModal'));
          modal.hide();
          currentProcess = null;
          abortController = null;
        });
        
        modal.show();
      }

      // Hide processing modal
      function hideProcessingModal() {
        const modal = bootstrap.Modal.getInstance(document.getElementById('processingModal'));
        if (modal) {
          modal.hide();
        }
        currentProcess = null;
        abortController = null;
      }

      // Find the video input (inside Video page)
      const videoInput = document.querySelector('#videoPage #videoUploader');
      if (!videoInput) {
        console.warn("No video input found in #videoPage");
        return;
      }

      const videoBox = videoInput.closest('.upload-box') || document.body;

      // build controls
      const ctrl = document.createElement('div'); ctrl.className = 'mt-3';
      const transBtn = document.createElement('button'); 
      transBtn.className = 'btn btn-outline-primary btn-sm me-2';
      transBtn.textContent = 'Transcribe';
      transBtn.disabled = true;

      ctrl.appendChild(transBtn);
      videoBox.appendChild(ctrl);

      const status = document.createElement('div'); 
      status.className = 'mt-2 small'; 
      status.style.whiteSpace = 'pre-wrap';
      videoBox.appendChild(status);

      const transcriptArea = document.createElement('textarea'); 
      transcriptArea.className='form-control mt-2';
      transcriptArea.rows = 8; 
      transcriptArea.placeholder = 'Transcript will appear here (or paste one)...';
      videoBox.appendChild(transcriptArea);

      const summaryDiv = document.createElement('div'); 
      summaryDiv.className='mt-2';
      videoBox.appendChild(summaryDiv);

      const chunksDiv = document.createElement('div'); 
      chunksDiv.className='mt-2 small text-muted';
      videoBox.appendChild(chunksDiv);

      // Create a container for MCQ generation controls (initially hidden)
      const mcqControlsContainer = document.createElement('div'); 
      mcqControlsContainer.className='mt-2';
      mcqControlsContainer.style.display = 'none';
      mcqControlsContainer.innerHTML = `
        <div class="row g-2 align-items-center">
          <div class="col-auto">
            <label class="form-label mb-0 small">Number of MCQs</label>
            <input id="videoNumQs" class="form-control form-control-sm" value="5" />
          </div>
          <div class="col-auto">
            <label class="form-label mb-0 small" style="visibility: hidden;">Generate</label>
            <button id="generateMCQsBtn" class="btn btn-primary btn-sm">Generate MCQs</button>
          </div>
        </div>
      `;
      videoBox.appendChild(mcqControlsContainer);

      const resultsWrap = document.createElement('div'); 
      resultsWrap.className='mt-3';
      videoBox.appendChild(resultsWrap);

      // enable buttons when user selects a file
      videoInput.addEventListener('change', (e) => {
        const f = e.target.files && e.target.files[0];
        if (f) {
          transBtn.disabled = false;
          status.textContent = `Selected file: ${f.name} (${Math.round(f.size/1024)} KB)`;
          console.log("Video selected", f);
        } else {
          transBtn.disabled = true;
        }
        // Hide MCQ controls when new file is selected
        mcqControlsContainer.style.display = 'none';
        resultsWrap.innerHTML = '';
        transcriptArea.value = '';
        summaryDiv.innerHTML = '';
        chunksDiv.innerHTML = '';
      });

      // Transcribe button
      transBtn.addEventListener('click', async () => {
        const f = videoInput.files && videoInput.files[0];
        if (!f) return alert('Choose a video file first.');
        
        showConfirmation('transcribe', async () => {
          try {
            const r = await transcribeVideo(f, "small");
            hideProcessingModal();
            
            if (r.status === 'success') {
              status.textContent = 'Transcription complete.';
              transcriptArea.value = r.transcript || '';
              summaryDiv.innerHTML = `<b>Summary</b><div class="small mt-1">${(r.summary || '').replace(/\n/g,'<br>')}</div>`;
              if (r.chunks && r.chunks.length) {
                chunksDiv.innerHTML = '<b>Chunk summaries:</b><br>' + r.chunks.slice(0,10).map((c,i)=>`<div>‚óè Chunk ${i+1}: ${c}</div>`).join('');
              } else chunksDiv.innerHTML = '';
              
              // Show MCQ generation controls after successful transcription
              mcqControlsContainer.style.display = 'block';
              if (r.global_state) updateDashboardFromResponse(r);
            } else if (r.status === 'cancelled') {
              status.textContent = 'Transcription cancelled.';
            } else {
              status.textContent = 'Transcription error: ' + (r.error || 'unknown');
              console.warn("transcribe error", r);
            }
          } catch (err) {
            hideProcessingModal();
            status.textContent = 'Network / JS error during transcription: ' + err;
            console.error(err);
          } finally {
            transBtn.disabled = false;
          }
        });
      });

      // Generate MCQs button (event delegation)
      mcqControlsContainer.addEventListener('click', async (e) => {
        if (e.target.id === 'generateMCQsBtn') {
          const numQs = parseInt(document.getElementById('videoNumQs').value || '0', 10);
          
          // Validate number of MCQs
          if (numQs <= 0) {
            status.textContent = 'Error: Number of MCQs must be a positive number (greater than 0)';
            return;
          }
          
          const curSummary = summaryDiv.innerText.trim() ? summaryDiv.innerText.trim() : (transcriptArea.value.trim() ? "" : "");
          
          showConfirmation('generate', async () => {
            try {
              let response;
              
              if (curSummary) {
                response = await generateVideoMCQs({ 
                  file: null, 
                  summary: curSummary, 
                  questionType: "mcq", 
                  numQs: numQs 
                });
              } else {
                const f = videoInput.files && videoInput.files[0];
                if (!f) {
                  status.textContent = 'Error: No file selected and no summary available.';
                  return;
                }
                response = await generateVideoMCQs({ 
                  file: f, 
                  summary: "", 
                  questionType: "mcq", 
                  numQs: numQs 
                });
              }
              
              hideProcessingModal();
              
              if (response.status === 'success') {
                status.textContent = `Generated ${response.mcqCount || 0} MCQs`;
                updateDashboardFromResponse(response);

                // downloads
                const keys = response.download_keys || {};
                const dlRow = document.createElement('div'); 
                dlRow.className = 'mb-2';
                
                if (keys.docx) {
                  const a = document.createElement('a'); 
                  a.href = `${backendBase}/download/${keys.docx}`; 
                  a.className='btn btn-outline-primary btn-sm me-2'; 
                  a.textContent='Download DOCX';
                  dlRow.appendChild(a);
                }
                if (keys.excel) {
                  const a = document.createElement('a'); 
                  a.href = `${backendBase}/download/${keys.excel}`; 
                  a.className='btn btn-outline-success btn-sm me-2'; 
                  a.textContent='Download Excel';
                  dlRow.appendChild(a);
                }
                if (keys.csv) {
                  const a = document.createElement('a'); 
                  a.href = `${backendBase}/download/${keys.csv}`; 
                  a.className='btn btn-outline-secondary btn-sm me-2'; 
                  a.textContent='Download CSV';
                  dlRow.appendChild(a);
                }

                resultsWrap.innerHTML = '';
                resultsWrap.appendChild(dlRow);

                // render results per topic
                const res = response.results || {};
                for (const topic of Object.keys(res)) {
                  const block = res[topic];
                  if (block.mcqs && block.mcqs.length) {
                    const h = document.createElement('div'); 
                    h.className='mt-2'; 
                    h.innerHTML = `<b>MCQs</b>`;
                    resultsWrap.appendChild(h);
                    
                    block.mcqs.forEach((m,i) => {
                      const div = document.createElement('div'); 
                      div.className='mb-2';
                      div.innerHTML = `<div><strong>${i+1}. ${m.question}</strong></div>`;
                      const ul = document.createElement('ul'); 
                      ul.className='small';
                      (m.options || []).forEach(opt => { 
                        const li = document.createElement('li'); 
                        li.textContent = opt; 
                        ul.appendChild(li); 
                      });
                      div.appendChild(ul);
                      if (m.answer) { 
                        const a = document.createElement('div'); 
                        a.className='text-success small'; 
                        a.textContent = `‚úÖ Answer: ${m.answer}`; 
                        div.appendChild(a); 
                      }
                      resultsWrap.appendChild(div);
                    });
                  }
                }
              } else if (response.status === 'cancelled') {
                status.textContent = 'MCQ generation cancelled.';
              } else {
                status.textContent = 'Generation error: ' + (response.error || 'unknown');
                console.warn("generation error", response);
              }
            } catch (err) {
              hideProcessingModal();
              console.error("generate exception", err);
              status.textContent = 'Network / JS error during generation: ' + err;
            }
          });
        }
      });

    }); // DOMContentLoaded
  </script>
  <!-- NAV & HISTORY HANDLING (Back button -> main page) -->
  <script>
    (function setupNavHistory(){
      const mainPage = document.getElementById('mainPage');
      const pages = Array.from(document.querySelectorAll('.page'));
      function showPageById(id) {
        // hide all pages & main
        pages.forEach(p => p.style.display = 'none');
        mainPage.style.display = 'none';
        // show requested
        const el = document.getElementById(id);
        if (el) el.style.display = 'block';
      }

      // add click handlers for nav buttons
      document.querySelectorAll('.nav-vertical .btn').forEach(btn => {
        btn.addEventListener('click', (ev) => {
          const pageId = btn.getAttribute('data-page');
          if (!pageId) return;
          showPageById(pageId);
          // push state so back button works
          history.pushState({page: pageId}, "", "#" + pageId);
        });
      });

      // handle popstate (back/forward)
      window.addEventListener('popstate', (e) => {
        if (e.state && e.state.page) {
          showPageById(e.state.page);
        } else {
          // go home
          pages.forEach(p => p.style.display = 'none');
          mainPage.style.display = 'flex';
        }
      });

      // initial load: if hash present, open that page (and push state)
      const initialHash = window.location.hash && window.location.hash.replace('#','');
      if (initialHash && document.getElementById(initialHash)) {
        // show target and replace history state
        showPageById(initialHash);
        history.replaceState({page: initialHash}, "", "#" + initialHash);
      } else {
        // show main page
        pages.forEach(p => p.style.display = 'none');
        mainPage.style.display = 'flex';
        history.replaceState({}, "", window.location.pathname);
      }
    })();
        function showPage(pageId) {
      console.log('showPage called with:', pageId);
      
      // Hide main page
      document.getElementById('mainPage').style.display = 'none';
      
      // Hide all content pages
      document.querySelectorAll('.page').forEach(page => {
        page.style.display = 'none';
      });
      
      // Show the requested page
      const targetPage = document.getElementById(pageId);
      if (targetPage) {
        targetPage.style.display = 'block';
      }
      
      // Handle specific page initialization
      if (pageId === 'questionsPage') {
        console.log('Questions page opened');
        
        loadFilterOptions();
        
        const searchInput = document.getElementById('searchInput');
        const questionTypeSelect = document.getElementById('questionTypeSelect');
        loadQuestionsFromDB(
          searchInput ? searchInput.value : '',
          questionTypeSelect ? questionTypeSelect.value : 'all'
        );
        initializeSearchFunctionality();
      }
      
      if (pageId === 'generatePaperPage') {
        loadPaperPdfs();
      }
      
      if (pageId === 'courseSelectionPage') {
        loadCourseSelectionFacultyFilters();
        initializeCourseSelectionSearchFunctionality();
      }
      
      if (pageId === 'courseQuestionsPage') {
        loadCourseQFacultyFilters();
        initializeCourseQSearchFunctionality();
        loadCourseQPdfFilters();
      }
      
      // Push to browser history
      history.pushState({page: pageId}, '', '#' + pageId);
    }
  </script>



<script>
  // global function to show main page / hide other pages
  function goHome() {
    try {
      // hide all content pages
      document.querySelectorAll('.page').forEach(p => p.style.display = 'none');
      // show main navigation
      const main = document.getElementById('mainPage');
      if (main) main.style.display = 'flex';

      // optionally show header/footer (if login state allows)
      const header = document.getElementById('mainHeader');
      const footer = document.getElementById('mainFooter');
      if (header) header.style.display = header.style.display === 'none' ? 'flex' : header.style.display;
      if (footer) footer.style.display = footer.style.display === 'none' ? 'block' : footer.style.display;

      // push history state so back button works
      history.pushState({ page: 'home' }, "", "#");

    } catch (e) {
      console.warn("goHome error", e);
    }
  }

  // handle browser back/forward: if user navigates back to empty state, show main page
  window.addEventListener('popstate', function (e) {
    if (!e.state || e.state.page === 'home') {
      document.querySelectorAll('.page').forEach(p => p.style.display = 'none');
      const main = document.getElementById('mainPage');
      if (main) main.style.display = 'flex';
    }
  });
</script>

</body>
</html>





